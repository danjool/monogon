<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Tech Challenge, Cannon, with webworker and improved stacking</title>
    <style>
      body { margin: 0; }
      canvas { display: block; }
    </style>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  </head>
  <body>
    <!-- Worker script, will be run in separate thread -->
    <script id="worker1" type="text/js-worker">
      import * as CANNON from 'https://cdn.skypack.dev/cannon-es';

      const boxSize = 0.2;
      const N = 20;
      const bodies = [];
      let originalPositions = [];
      let originalOrientations = [];
      let isAttracted = true;
      let t = 0.0;

      const world = new CANNON.World();
      world.gravity.set(0, -9.82, 0);
      world.solver.iterations = 10;
      world.solver.tolerance = 0.001;

      const groundShape = new CANNON.Plane();
      const groundBody = new CANNON.Body({ mass: 0 });
      groundBody.addShape(groundShape);
      groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(groundBody);

      const boxShape = new CANNON.Box(new CANNON.Vec3(boxSize, boxSize, boxSize));
      for (let i = 0; i < N; i++) {
        const body = new CANNON.Body({ 
          mass: 1,
          linearDamping: 0.4,
          angularDamping: 0.4
        });
        body.addShape(boxShape);
        const position = new CANNON.Vec3(0, i * boxSize * 2. +boxSize, 0);
        body.position.copy(position);
        body.fixedRotation = true; // Prevent rotation
        originalPositions.push(position.clone());
        originalOrientations.push(body.quaternion.clone());
        bodies.push(body);
        world.addBody(body);
      }

      function toggleAttraction() {
        isAttracted = !isAttracted;
        t = 0.0;
        for (let i = 0; i < bodies.length; i++) {
          const body = bodies[i];
          if (isAttracted) {
            body.mass = 0.1;
            body.fixedRotation = true;
          } else {
            body.mass = 1;
            body.fixedRotation = false;
          }
        }
      }

      self.addEventListener('message', (event) => {
        if (event.data.action === 'toggleAttraction') {
          toggleAttraction();
        } else {
          t += 0.01;
          const { positions, quaternions, timeStep } = event.data;

          world.fixedStep(timeStep);

          if (isAttracted) {
            for (let i = 0; i < bodies.length; i++) {
              const body = bodies[i];
              const targetPos = originalPositions[i];
              // raise the target position by .01 per i biased towards low t
              // targetPos.y += i/(1. + t) * 0.001;
              const targetQuat = originalOrientations[i];
              
              // Position tweening
              const positionDiff = targetPos.vsub(body.position);
              const positionStep = positionDiff.scale(0.05 * t);
              body.position.vadd(positionStep, body.position);

              // Rotation tweening
              const currentQuat = body.quaternion;
              currentQuat.slerp(targetQuat, 0.1 * t, currentQuat);

              // Apply a small upward force to counteract gravity
              body.applyForce(new CANNON.Vec3(0, 1, 0).scale(body.mass * 9.82 * 1.1), body.position);
            }
          }

          for (let i = 0; i < bodies.length; i++) {
            const body = bodies[i];
            positions[i * 3 + 0] = body.position.x;
            positions[i * 3 + 1] = body.position.y;
            positions[i * 3 + 2] = body.position.z;
            quaternions[i * 4 + 0] = body.quaternion.x;
            quaternions[i * 4 + 1] = body.quaternion.y;
            quaternions[i * 4 + 2] = body.quaternion.z;
            quaternions[i * 4 + 3] = body.quaternion.w;
          }

          self.postMessage(
            {
              positions,
              quaternions,
              isAttracted
            },
            [positions.buffer, quaternions.buffer]
          );
        }
      });
    </script>

    <script type="module">
      import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.112.1/examples/jsm/controls/OrbitControls.js';
      import Stats from 'https://unpkg.com/three@0.122.0/examples/jsm/libs/stats.module.js';

      const timeStep = 1 / 60;
      const N = 20;
      const boxSize = 0.2;
      const MAX_PARTICLES = 80;
      const PARTICLES_PER_BOX = 4;

      let lastTime = performance.now();
      let positions = new Float32Array(N * 3);
      let quaternions = new Float32Array(N * 4);
      let isAttracted = true;

      let workerScript = document.querySelector('#worker1').textContent;
      const blob = new Blob([workerScript], { type: 'text/javascript' });
      const worker = new Worker(window.URL.createObjectURL(blob), { type: 'module' });

      let sendTime;

      function requestDataFromWorker() {
        sendTime = performance.now();
        worker.postMessage(
          {
            timeStep,
            positions,
            quaternions,
            isAttracted
          },
          [positions.buffer, quaternions.buffer]
        );
      }

      worker.addEventListener('message', (event) => {
        positions = event.data.positions;
        quaternions = event.data.quaternions;
        isAttracted = event.data.isAttracted;

        let allRested = false;
        let greatestDistance = 0;
        let greatestRotation = 0;
        let highestY = 0;
        for (let i = 0; i < meshes.length; i++) {
          const prevPosition = meshes[i].position.clone();
          const prevQuaternion = meshes[i].quaternion.clone();
          meshes[i].position.set(positions[i * 3 + 0], positions[i * 3 + 1], positions[i * 3 + 2]);
          meshes[i].quaternion.set(
            quaternions[i * 4 + 0],
            quaternions[i * 4 + 1],
            quaternions[i * 4 + 2],
            quaternions[i * 4 + 3]
          );

          const distanceToPrevious = meshes[i].position.distanceTo(prevPosition);
          const rotationDiff = meshes[i].quaternion.angleTo(prevQuaternion)/Math.PI;
          greatestDistance = Math.max(greatestDistance, distanceToPrevious);
          greatestRotation = Math.max(greatestRotation, rotationDiff);
          if (distanceToPrevious < 0.01) {
            allRested = allRested && true;
          }
          highestY = Math.max(highestY, meshes[i].position.y);
        }

        if (greatestDistance < .0001 && !isAttracted && greatestRotation < .0005 && highestY < 3.1) {
          meshes.forEach(mesh=>{
            if (Math.abs(mesh.position.y - boxSize) < 0.01) emitParticlesForBox(mesh);
          });
        }

        const delay = timeStep * 1000 - (performance.now() - sendTime);
        setTimeout(requestDataFromWorker, Math.max(delay, 0));
      });

      worker.addEventListener('error', (event) => {
        console.error(event.message);
      });

      let camera, scene, renderer, stats, controls;
      const meshes = [];
      const particles = [];
      const particlePool = [];

      initThree();
      animate();
      requestDataFromWorker();

      function createNumberTexture(number) {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = 'black';
        context.font = '48px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(number, canvas.width / 2, canvas.height / 2);
        return new THREE.CanvasTexture(canvas);
      }

      function initThree() {
        camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.5, 10000);
        camera.position.set(Math.cos(Math.PI / 5) * 30, 5, Math.sin(Math.PI / 5) * 30);

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 500, 10000);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(scene.fog.color);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        stats = new Stats();
        document.body.appendChild(stats.dom);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enablePan = false;
        controls.dampingFactor = 0.3;
        controls.minDistance = 10;
        controls.maxDistance = 500;

        const ambientLight = new THREE.AmbientLight(0x666666);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.75);
        const distance = 20;
        directionalLight.position.set(distance, distance, distance);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.left = -distance;
        directionalLight.shadow.camera.right = distance;
        directionalLight.shadow.camera.top = distance;
        directionalLight.shadow.camera.bottom = -distance;
        directionalLight.shadow.camera.far = 3 * distance;
        directionalLight.shadow.camera.near = distance;
        scene.add(directionalLight);

        const floorGeometry = new THREE.PlaneBufferGeometry(100, 100, 1, 1);
        floorGeometry.rotateX(-Math.PI / 2);
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x777777 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.receiveShadow = true;
        scene.add(floor);

        const cubeGeometry = new THREE.BoxBufferGeometry(boxSize*2.0, boxSize*2.0, boxSize*2.0, 10, 10);
        const haloGeometry = new THREE.RingBufferGeometry(0.6, 0.8, 32);
        const haloMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });

        for (let i = 0; i < N; i++) {
          const numberTexture = createNumberTexture(i + 1);
          const cubeMaterial = new THREE.MeshPhongMaterial({ map: numberTexture });

          const cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial);
          cubeMesh.castShadow = true;
          cubeMesh.userData.particlesEmitted = 0;

          const haloMesh = new THREE.Mesh(haloGeometry, haloMaterial);
          haloMesh.position.set(0, -boxSize, 0);
          haloMesh.rotation.x = Math.PI / 2;
          cubeMesh.add(haloMesh);

          meshes.push(cubeMesh);
          scene.add(cubeMesh);
        }

        const particleGeometry = new THREE.SphereBufferGeometry(0.25, 8, 8);
        const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        for (let i = 0; i < MAX_PARTICLES; i++) {
          const particle = new THREE.Mesh(particleGeometry, particleMaterial);
          particle.visible = false;
          scene.add(particle);
          particlePool.push(particle);
        }

        window.addEventListener('resize', onWindowResize);


      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function emitParticlesForBox(box) {
        if (box.userData.particlesEmitted >= PARTICLES_PER_BOX) return;

        const particlesToEmit = Math.min(PARTICLES_PER_BOX - box.userData.particlesEmitted, particlePool.length - particles.length);

        for (let i = 0; i < particlesToEmit; i++) {
          let particle = particlePool.find(p => !p.visible);
          if (!particle) break;

          particle.position.copy(box.position);
          particle.visible = true;
          particle.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            Math.random() * 2 + 1,
            (Math.random() - 0.5) * 0.5
          );
          particle.userData.lifetime = 2;
          particle.userData.originalBox = box;
          particles.push(particle);
          box.userData.particlesEmitted++;
        }
      }

      function updateParticles(deltaTime) {
        for (let i = particles.length - 1; i >= 0; i--) {
          const particle = particles[i];
          particle.position.add(particle.userData.velocity.clone().multiplyScalar(deltaTime));
          particle.userData.lifetime -= deltaTime;

          if (particle.userData.lifetime <= 0) {
            particle.visible = false;
            particle.position.copy(particle.userData.originalBox.position);
            particle.userData.originalBox.userData.particlesEmitted--;
            particles.splice(i, 1);
          }
        }
      }

      function animate() {
        requestAnimationFrame(animate);

        const currentTime = performance.now();
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        updateParticles(deltaTime);
        controls.update();
        renderer.render(scene, camera);
        stats.update();
      }

      document.addEventListener('keydown', (event) => {
        if (event.key === 't') {
          toggleAttraction();
        }
      });
      // also toggle attraction every 10 seconds
      setInterval(toggleAttraction, 10000);

      function toggleAttraction() {
        worker.postMessage({ action: 'toggleAttraction' });
        meshes.forEach(mesh => {
          mesh.children[0].visible = !isAttracted;
        });
      }
    </script>
  </body>
</html>