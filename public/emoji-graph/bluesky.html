<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bluesky Entity Graph</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="3d-graph" style="width: 100vw; height: 100vh;"></div>

    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph"></script>
    <script src="https://unpkg.com/three-spritetext"></script>
    <script src="https://unpkg.com/d3@6.7.0"></script>
    <script>
        const graphData = {
            nodes: [
    // Infrastructure
    { id: 'PDS', emoji: 'ðŸ¢', kind: 'infrastructure', name: 'Personal Data Store' },
    { id: 'APPVIEW', emoji: 'ðŸ”', kind: 'infrastructure' },
    { id: 'RELAY', emoji: 'ðŸ“¡', kind: 'infrastructure' },
    
    // Core AT Protocol
    { id: 'REPO', emoji: 'ðŸ“¦', kind: 'at-protocol' },
    { id: 'DID', emoji: 'ðŸ†”', kind: 'at-protocol' },
    { id: 'HANDLE', emoji2: '@', emoji: 'ðŸ“¦', kind: 'at-protocol' },
    { id: 'RECORD', emoji: 'ðŸ“', kind: 'at-protocol' },
    { id: 'COLLECTION', emoji: 'ðŸ“‹', kind: 'at-protocol' },
    { id: 'NSID', emoji: 'ðŸ—‚ï¸', kind: 'at-protocol' },
    { id: 'TID', emoji: 'â±ï¸', kind: 'at-protocol' },
    { id: 'CID', emoji: 'ðŸ“Ž', kind: 'at-protocol' },
    { id: 'LEXICON', emoji: 'ðŸ“œ', kind: 'at-protocol' },
    
    // Social
    { id: 'ACTOR', emoji: 'ðŸ§‘', kind: 'social' },
    { id: 'POST', emoji: 'ðŸ“®', kind: 'social' },
    { id: 'THREAD', emoji: 'ðŸ§µ', kind: 'social' },
    { id: 'LIKE', emoji: 'ðŸ‘', kind: 'social' },
    { id: 'REPOST', emoji: 'ðŸ”„', kind: 'social' },
    { id: 'LIST', emoji: 'ðŸ“„', kind: 'social' },
    { id: 'LIST-ITEM', emoji: 'ðŸ“„', kind: 'social' },
    { id: 'NOTIFICATION', emoji: 'ðŸ””', kind: 'social' },
    
    // Content
    { id: 'FACET', emoji: 'ðŸ” ', kind: 'content' },
    { id: 'FEATURE', emoji: 'â­', kind: 'content' },
    { id: 'MENTION', emoji: '@', kind: 'content' },
    { id: 'LINK', emoji: 'ðŸ”—', kind: 'content' },
    { id: 'LANGUAGE', emoji: 'ðŸ—£ï¸', kind: 'content' },
    { id: 'LABEL', emoji: 'ðŸ·ï¸', kind: 'content' },
    
    // Media
    { id: 'BLOB', emoji: 'ðŸ’¾', kind: 'media' },
    { id: 'BLOB-REF', emoji: 'ðŸ”—', kind: 'media' },
    { id: 'EXTERNAL-EMBED', emoji: 'ðŸŒ', kind: 'media' },
    { id: 'THUMBNAIL-BLOB', emoji: 'ðŸ–¼ï¸', kind: 'media' },
    { id: 'POST-IMAGE', emoji: 'ðŸ“¸', kind: 'media' },
    { id: 'VIDEO-BLOB', emoji: 'ðŸŽ¥', kind: 'media' },
    { id: 'PROFILE-BLOB', emoji: 'ðŸ‘¤', kind: 'media' },
    { id: 'BANNER-BLOB', emoji: 'ðŸ§©', kind: 'media' },
    { id: 'RECORD-EMBED', emoji: 'ðŸ”„', kind: 'media' },
    { id: 'URI-CID', emoji: 'ðŸ”', kind: 'media' }
],
            links: [
    // Infrastructure Layer
    { source: 'PDS', target: 'APPVIEW', type: 'syncs with' },
    { source: 'APPVIEW', target: 'REPO', type: 'reads from' },
    { source: 'PDS', target: 'REPO', type: 'hosts' },
    { source: 'PDS', target: 'RELAY', type: 'syncs to' },
    { source: 'RELAY', target: 'REPO', type: 'aggregates' },

    // Identity Layer
    { source: 'REPO', target: 'DID', type: 'identified by' },
    { source: 'REPO', target: 'HANDLE', type: 'identified by' },
    { source: 'REPO', target: 'ACTOR', type: 'owned by' },
    { source: 'REPO', target: 'COLLECTION', type: 'contains' },
    { source: 'REPO', target: 'LABEL', type: 'tagged with' },

    // Data Structure Layer
    { source: 'COLLECTION', target: 'RECORD', type: 'contains' },
    { source: 'POST', target: 'RECORD', type: 'is a' },
    { source: 'COLLECTION', target: 'NSID', type: 'typed by' },
    { source: 'RECORD', target: 'CID', type: 'versioned by' },
    { source: 'RECORD', target: 'TID', type: 'keyed by' },
    { source: 'RECORD', target: 'LEXICON', type: 'conforms to' },
    { source: 'RECORD', target: 'LABEL', type: 'tagged with' },

    // Lists and Social
    { source: 'LIST', target: 'RECORD', type: 'is a' },
    { source: 'ACTOR', target: 'LIST', type: 'creates' },
    { source: 'LIST', target: 'LIST-ITEM', type: 'contains' },
    { source: 'LIST-ITEM', target: 'ACTOR', type: 'references' },

    // Content Layer
    { source: 'ACTOR', target: 'POST', type: 'creates' },
    { source: 'ACTOR', target: 'PROFILE-BLOB', type: 'has profile in' },
    { source: 'ACTOR', target: 'BANNER-BLOB', type: 'has banner in' },
    { source: 'ACTOR', target: 'ACTOR', type: 'follows' },

    // Notifications
    { source: 'NOTIFICATION', target: 'ACTOR', type: 'sent to' },
    { source: 'NOTIFICATION', target: 'POST', type: 'references' },

    // Posts and Content
    { source: 'POST', target: 'FACET', type: 'contains' },
    { source: 'POST', target: 'EXTERNAL-EMBED', type: 'embeds websites' },
    { source: 'POST', target: 'RECORD-EMBED', type: 'quotes records' },
    { source: 'POST', target: 'LIKE', type: 'receives' },
    { source: 'POST', target: 'REPOST', type: 'gets' },
    { source: 'POST', target: 'THREAD', type: 'belongs to' },
    { source: 'POST', target: 'LANGUAGE', type: 'written in' },
    { source: 'POST', target: 'POST', type: 'replies to' },

    // Rich Text Features
    { source: 'FACET', target: 'FEATURE', type: 'contains' },
    { source: 'FEATURE', target: 'MENTION', type: 'references actor' },
    { source: 'FEATURE', target: 'LINK', type: 'references url' },

    // Media & Embeds
    { source: 'BLOB', target: 'BLOB-REF', type: 'referenced by' },
    { source: 'EXTERNAL-EMBED', target: 'THUMBNAIL-BLOB', type: 'has' },
    { source: 'THUMBNAIL-BLOB', target: 'BLOB', type: 'is a' },
    { source: 'POST', target: 'POST-IMAGE', type: 'attaches' },
    { source: 'POST-IMAGE', target: 'BLOB', type: 'is a' },
    { source: 'PROFILE-BLOB', target: 'BLOB', type: 'is a' },
    { source: 'BANNER-BLOB', target: 'BLOB', type: 'is a' },
    { source: 'VIDEO-BLOB', target: 'BLOB', type: 'is a' },
    { source: 'RECORD-EMBED', target: 'URI-CID', type: 'references' },
    { source: 'POST', target: 'URI-CID', type: 'identified by' }
]
        };

        function createColoredEmoji(emoji, color, size = 64, emoji2) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            if(color){
                ctx.font = `${size * .75}px Arial`;
                ctx.fillText(emoji, 0, size * .8);
                ctx.globalCompositeOperation = 'source-in';
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
                ctx.fillRect(0, 0, size, size);    
            }

            // Draw emoji
            ctx.globalCompositeOperation = 'destination-over'; // other optoins: 'source-atop', 'source-over', 'destination-in', 'destination-out', 'destination-over', 'lighter', 'copy', 'xor'
            ctx.font = `${size * .75}px Arial`;
            ctx.fillText(emoji, 0, size * .8); // fillText args go: text, x, y, maxWidth, so y = size to center vertically

            if (emoji2) {
                console.log('emoji2', emoji2);  
                ctx.font = `${size * .4}px Arial`;
                ctx.fillStyle = `rgba(255, 255, 255, 1.0)`;
                ctx.fillText(emoji2, size*.5, size * .8);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            return new THREE.Sprite(material);
        }

        let linkSprites = [];
        const Graph = ForceGraph3D()
            (document.getElementById('3d-graph'))
            .graphData(graphData)
            .showNavInfo(false)
            .nodeThreeObject(node => {
                const group = new THREE.Group();
                const colors = {
                    'infrastructure': '#ff7f50',
                    'at-protocol': '#4169e1', 
                    'social': '#32cd32',
                    'content': '#ba55d3',
                    'media': '#ffd700'
                };
                
                const mainSprite = createColoredEmoji(node.emoji, colors[node.kind], 64, node.emoji2);
                mainSprite.scale.set(10, 10, 1);
                group.add(mainSprite);
                
                // if (node.emoji2) {
                //     const secondarySprite = createColoredEmoji(node.emoji2, colors[node.kind], 24);
                //     secondarySprite.position.set(5, -5, 0);
                //     secondarySprite.scale.set(5, 5, 1);
                //     group.add(secondarySprite);
                // }
                
                return group;
            })
            .linkWidth(0.2)
            .linkOpacity(0.5)
            // .linkDirectionalParticles(2)
            // .linkDirectionalParticleWidth(1.5)
            // .linkDirectionalParticleSpeed(0.005)
            .onNodeDragEnd(node => {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            })
            .nodeLabel(node => `${node.id} ${node.emoji}`)
            .backgroundColor('#161e27')
            .linkColor(link => '#2e4052')
            .linkPositionUpdate((sprite, { start, end }) => {
                if (sprite) {
                    const middlePos = Object.assign(...['x', 'y', 'z'].map(c => ({
                        [c]: start[c] + (end[c] - start[c]) / 2
                    })));
                    Object.assign(sprite.position, middlePos);
                }
            })
            .linkThreeObjectExtend(true)
            .linkThreeObject(link => {
                const sprite = new SpriteText(`${link.type}`);
                sprite.color = 'lightgrey';
                sprite.textHeight = 3;
                sprite.visible = false;
                linkSprites.push(sprite);
                return sprite;
            })
            .onLinkHover(link => {
                if (link) { 
                    linkSprites.forEach(sprite => sprite.visible = false);
                    linkSprites[link.index].visible = true; 
                }
            })
            .linkHoverPrecision(.1) 

            //  func to return a node's order in the graph
            const getNodeOrder = node => node ? graphData.links.filter(link => (link.source === node.id || link.target === node.id)).length : 0;
            const getLinkOrder = link => link ? getNodeOrder(link.source) + getNodeOrder(link.target) : 0;

            function linkSpreadForce() { // inefficient to push nodes away from links
                let nodes;
                let links;
                const strength = 4;
                const minDistance = 10;

                let nodesToValidLinks = {}; // where valid links are within two degrees of separation

                function force(alpha) {
                    nodes.forEach(node => {
                        let fx = 0, fy = 0, fz = 0;
                        
                        // Check distance to each link
                        if (!links) return;
                        links.forEach(link => {
                            if (node === link.source || node === link.target) return;
                            
                            // Get vector from link source to target
                            const dx = link.target.x - link.source.x;
                            const dy = link.target.y - link.source.y;
                            const dz = link.target.z - link.source.z;
                            
                            // Project node position onto line
                            const t = ((node.x - link.source.x) * dx + 
                                    (node.y - link.source.y) * dy + 
                                    (node.z - link.source.z) * dz) / 
                                    (dx * dx + dy * dy + dz * dz);
                            
                            if (t < 0 || t > 1) return; // Outside link segment
                            
                            // Find closest point on line
                            const projX = link.source.x + t * dx;
                            const projY = link.source.y + t * dy;
                            const projZ = link.source.z + t * dz;
                            
                            // Vector from projection to node
                            const vx = node.x - projX;
                            const vy = node.y - projY;
                            const vz = node.z - projZ;
                            
                            // Distance from node to line
                            const dist = Math.sqrt(vx * vx + vy * vy + vz * vz);
                            
                            if (dist < minDistance) {
                                const factor = strength * alpha * (1 - dist / minDistance);
                                fx += vx / dist * factor;
                                fy += vy / dist * factor;
                                fz += vz / dist * factor;
                            }
                        });
                        
                        node.vx += fx;
                        node.vy += fy;
                        node.vz += fz;
                    });
                }

                force.initialize = (_nodes, ..._) => {
                    nodes = _nodes;
                };

                force.links = (_) => {
                    return _.length ? (links = _, force) : links;
                };

                return force;
            }

            Graph.d3Force('link').distance(link => 5 + 15 * getLinkOrder(link));
            Graph.d3Force('link-spread', linkSpreadForce())
    .d3Force('link-spread').links(Graph.graphData().links);


    </script>
</body>
</html>