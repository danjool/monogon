<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="//unpkg.com/force-graph"></script>
    <script src="//unpkg.com/three"></script>
    <script src="//unpkg.com/d3-force-3d"></script>
    <script src="//unpkg.com/3d-force-graph"></script>
    <script src="//unpkg.com/three-spritetext"></script>
    
    <title>fdg - concepts</title>
</head>
<style>
	*
{
    margin: 0;
    padding: 0;
}

html,
body
{
    height: 100vh;
    /* font-family: 'Poppins'; */
}

body {
    overflow-x: hidden;
}

/* canvas */
.webgl
{
    position: absolute;
    top: 0;
    left: 0;
    outline: none;
    mix-blend-mode: exclusion;
}

.container {
    height: 100vh;
    display: grid;
    place-items:  center;
}

h1 {
   font-size: 5rem;
   text-transform: uppercase;
   color:black; 
}

.scene-tooltip{
    overflow:hidden;
}

.scene-container{
    overflow:hidden;
}
</style>

<body>
    
        <div>
            <div id="3d-graph"></div>    
        </div>

        <script type="module" >
        	const imagesFolder = 'images/'
			const circleAlphaMap = new THREE.TextureLoader().load(imagesFolder + "orb.png");
			const rectAlphaMap = new THREE.TextureLoader().load(imagesFolder + "cropped-rect-mask.jpg");


function setNodeObjectsToSpriteLabels(fGraph, textHeight, color) {
  if (!color) color = (n) => "white";
  fGraph
    .nodeThreeObject((node) => {
    	if (node.image) {
		const imgTexture = new THREE.TextureLoader().load(
		imagesFolder + node.image
		);
		const material = new THREE.SpriteMaterial({
		map: imgTexture,
		alphaMap: node.type === "event" ? rectAlphaMap : circleAlphaMap,
		});
		const sprite = new THREE.Sprite(material);
		sprite.scale.set(node.type === "event" ? 24 : 12, 12);
		return sprite;
    } else {
    	let label = node.label ? node.label : node.id;

      const sprite = new SpriteText(label);
      sprite.material.depthWrite = false; // make sprite background transparent
      sprite.color = color(node);
      sprite.textHeight = textHeight;
      return sprite;	
    }
      
    })
    .linkDirectionalParticles(2)
    .linkDirectionalParticleSpeed(0.025)
    .linkDirectionalParticleWidth(2)
    .linkDirectionalParticleColor("white")
    .linkDirectionalParticleResolution(2);
}

function setEdgeLabelByAttribute(fGraph, attribute) {
  fGraph.linkHoverPrecision(3.0);
  fGraph.linkLabel((link) => {
    if (link[attribute]) {
      return link[attribute];
    } else return "(missing)";
  });
}

function setEdgeVisualsByAttributeMap(fGraph, attribute, valueMap) {
	let color = new THREE.Color()
	fGraph.linkColor((link) => {
		if ( link.hasOwnProperty(attribute) && valueMap.hasOwnProperty(link[attribute]) ) {
			color.set(valueMap[ link[attribute] ])
			return color.getStyle();
		}
	});
}

function setLinkStrengthsFromAttribute(fGraph, attribute, valueToStrengthMap) {
  fGraph.d3Force("link").strength((link) => {
    if (link[attribute] && valueToStrengthMap.hasOwnProperty(link[attribute])) {
      return valueToStrengthMap[link[attribute]];
    } else return 1.0;
  });
}

function setLinkDistancesFromAttribute(fGraph, attribute, valueToDistanceMap) {
  fGraph.d3Force("link").distance((link) => {
    if (link[attribute] && valueToDistanceMap.hasOwnProperty(link[attribute])) {
      return valueToDistanceMap[link[attribute]];
    } else return 1.0;
  });
}


function pinNode(node) {
  node.fx = node.x;
  node.fy = node.y;
  node.fz = node.z;
}

function unpinNode(node) {
  node.fx = null;
  node.fy = null;
  node.fz = null;
}

function togglePinNode(node) {
	console.log("togglePinNode", node)
  if (node.fx !== null) unpinNode(node);
  else pinNode(node);
}

function unpinAllNodes() {
  fGraph.graphData().nodes.forEach(unpinNode);
}


// function setNodeObjectsToImageLabels() {
// 	const imagesFolder = "./images/";
// 	setNodesLabelByAttribute();
// 	fGraph.nodeThreeObject((node) => {
//     if (node.image) {
// 		const imgTexture = new THREE.TextureLoader().load(
// 		imagesFolder + node.image
// 		);
// 		const material = new THREE.SpriteMaterial({
// 		map: imgTexture,
// 		alphaMap: node.type === "event" ? rectAlphaMap : circleAlphaMap,
// 		});
// 		const sprite = new THREE.Sprite(material);
// 		sprite.scale.set(node.type === "event" ? 24 : 12, 12);
// 		return sprite;
//     }
// });

// concepts-nodes-links
fetch('./data/concepts-nodes-links.json').then(res => res.json()).then(data => {
// fetch('./data/math-nodes-links.json').then(res => res.json()).then(data => {
  const fGraph = ForceGraph3D({rendererConfig:{ antialias: true, alpha: true, clearColor: "black" } } )
  (document.getElementById('3d-graph'))
    .graphData(data)
    .nodeId('id')
    .nodeAutoColorBy('id')
    .onNodeClick((node, event) => {
	    togglePinNode(node);
    })
    .onNodeDragEnd((node,event)=>{
    	pinNode(node)
    })
    .linkWidth(1.1)
    .linkOpacity(.5)
    .linkResolution(5)
    .d3AlphaDecay(0.0)
    .d3VelocityDecay(0.9)
    .cooldownTicks(Infinity)
    .cooldownTime(Infinity)

    fGraph.d3Force("center").strength(1.);

    setNodeObjectsToSpriteLabels( fGraph, 8, null )
    let relationToColorMap = {
        IsA: "cyan",
        Synonym: "blue",
        Antonym: "red",
  	};
  	setEdgeVisualsByAttributeMap(fGraph, "relation", relationToColorMap);

	let valToStr = {
	    IsA: 0.5,
	    Synonym: 0.5,
	    Antonym: 0.5,
	  };
  	setLinkStrengthsFromAttribute( fGraph, "relation", valToStr)

  	let valToDist = {
	    IsA: 200.0,
	    Synonym: 300.0,
	    Antonym: 1300.0,
	  };
  	setLinkDistancesFromAttribute(fGraph, "relation", valToDist);

  	setEdgeLabelByAttribute(fGraph, "relation");

	fGraph.scene().background = "red"
  	console.log(fGraph.scene(), fGraph.graphData())

});
</script>
    
</body>
</html>