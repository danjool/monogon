<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="//unpkg.com/force-graph"></script>
    <script src="//unpkg.com/three"></script>
    <script src="//unpkg.com/d3-force-3d"></script>
    <script src="//unpkg.com/3d-force-graph"></script>
    <script src="//unpkg.com/three-spritetext"></script>
    
    <title>fdg - concepts</title>
</head>
<style>
	*
{
    margin: 0;
    padding: 0;
}

html,
body
{
    height: 100vh;
    /* font-family: 'Poppins'; */
}

body {
    overflow-x: hidden;
}

/* canvas */
.webgl
{
    position: absolute;
    top: 0;
    left: 0;
    outline: none;
    mix-blend-mode: exclusion;
}

.container {
    height: 100vh;
    display: grid;
    place-items:  center;
}

h1 {
   font-size: 5rem;
   text-transform: uppercase;
   color:black; 
}

.scene-tooltip{
    overflow:hidden;
}

.scene-container{
    overflow:hidden;
}
</style>

<body>
    
        <div>
            <div id="3d-graph"></div>    
        </div>

        <script type="glsl" id="vshader">
          attribute float vertPos; 
          varying float fragPos; 
          void main() { 
            gl_Position = projectionMatrix*modelViewMatrix*vec4(position, 1.0); 
            fragPos = vertPos; 
          }
        </script>

        <script type="glsl" id="fshader">
          uniform vec3 color; 
          varying float fragPos; 
          void main() { 
            gl_FragColor = vec4(color, 1.0); 
          }
        </script>

        <script type="module" >

      let fGraph
    	const imagesFolder = 'images/'
			const circleAlphaMap = new THREE.TextureLoader().load(imagesFolder + "orb.png");
			const rectAlphaMap = new THREE.TextureLoader().load(imagesFolder + "cropped-rect-mask.jpg");

window.addEventListener("keyup", (e) => onKeyUp(e), false);
async function onKeyUp(event) {
  switch (event.key) {
    case "t":
      fGraph.graphData().nodes.forEach(node=> {
        if(node.hasOwnProperty('time')){
            node.fy = 100.0*Math.pow(node.time+500, -10.0)-400 //-Math.log(-node.time + 1900) 
        } else {
            delete node.fy
        }
      })
      break;
    
    case "a":

        fGraph.graphData().nodes.forEach(node=> node.visible= true )
        reinitializeForceGraph(fGraph)
    break;

    case "f":
        console.log("fGraph graphData", fGraph.graphData())
    break;
    case "u":
        unpinAllNodes()
    break;
  }
}

function setNodeObjectsToSpriteLabels(fGraph, textHeight, color) {
  if (!color) color = (n) => "white";
  fGraph
    .nodeThreeObject((node) => {
    	if (node.image) {
			const imgTexture = new THREE.TextureLoader().load( imagesFolder + node.image, (img)=>{
				} )
				const material = new THREE.SpriteMaterial({
				map: imgTexture,
				alphaMap: node.type === "person" ? circleAlphaMap : null,
			})
			const sprite = new THREE.Sprite(material);

			const width = 24
			const height = node.ratio ? node.ratio*width : width
			sprite.scale.set(width, height)
			// sprite.scale.set(imgTexture.source.data.width, imgTexture.source.data.height) // async issue, don't have imgTexture.source.data yet
			// console.log("imgTexture", imgTexture.source, sprite, node.ratio, sprite)
			return sprite;
			
    	} else {
    		let label = node.label ? node.label : node.id;

	      const sprite = new SpriteText(label);
	      sprite.material.depthWrite = false; // make sprite background transparent
	      sprite.color = color(node);
	      sprite.textHeight = textHeight;
      	return sprite;	
		}
    })
}

function setEdgeLabelByAttribute(fGraph, attribute) {
  fGraph.linkHoverPrecision(3.0);
  fGraph.linkLabel((link) => {
    if (link[attribute]) {
      return link[attribute];
    } else return "(missing)";
  });
}

function setEdgeVisualsByAttributeMap(fGraph, attribute, valueMap) {
	let color = new THREE.Color()
	fGraph.linkColor((link) => {
		if ( link.hasOwnProperty(attribute) && valueMap.hasOwnProperty(link[attribute]) ) {
			color.set(valueMap[ link[attribute] ])
			return color.getStyle();
		}
	});
}

function setLinkStrengthsFromAttribute(fGraph, attribute, valueToStrengthMap) {
  fGraph.d3Force("link").strength((link) => {
    if(link['serendipity']){
      console.log("serendipity", link)
      return 0.0} 
    if(!link.source.visible || !link.target.visible){return 0.0}
    if (link[attribute] && valueToStrengthMap.hasOwnProperty(link[attribute])) {
      return valueToStrengthMap[link[attribute]];
    } else return 1.0;
  });
}

function setLinkGradient(fGraph){
  fGraph.linkThreeObject(link=>{
    const colors = new Float32Array([1,0,0,0,0,1]
      //[].concat(
            // ...[link.source, link.target]
              // .map(nodeColorScale)
              // .map(d3.color)
              // .map(({ r, g, b }) => [r, g, b].map(v => v / 255)
              
      );

          const material = new THREE.LineBasicMaterial({ 
            vertexColors: THREE.VertexColors, transparent: true, opacity:.5
          });

          // const material = new THREE.ShaderMaterial({
          //     vertexShader: document.getElementById('vshader').textContent,
          //     fragmentShader: document.getElementById('fshader').textContent,
          //     // uniforms: {
          //     //   color: {
          //     //       type: 'v3',
          //     //       value: col
          //     //   }
          //     // },
          //     // vertexColors: THREE.VertexColors,
          //     depthWrite: false,
          //     depthTest: false,
          //     lineWidth: 1, //this always defaults to 1, unfortunately
          //     transparent: true
          // });

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(2 * 3), 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

          return new THREE.Line(geometry, material);
  })
}

function setLinkDistancesFromAttribute(fGraph, attribute, valueToDistanceMap) {
  fGraph.d3Force("link").distance((link) => {
    if (link[attribute] && valueToDistanceMap.hasOwnProperty(link[attribute])) {
      return valueToDistanceMap[link[attribute]];
    } else return 50.0;
  });
}


function pinNode(node) {
  node.fx = node.x;
  node.fy = node.y;
  node.fz = node.z;
}

function unpinNode(node) {
  node.fx = null;
  node.fy = null;
  node.fz = null;
}

function togglePinNode(node) {
	console.log("togglePinNode", node)
  if (node.fy ) {
    unpinNode(node)
    return true
  } else {
    pinNode(node)
    return false
  }
}

function unpinAllNodes() {
  fGraph.graphData().nodes.forEach(unpinNode);
  fGraph.d3Force("center").strength(1.0)
}

// concepts-nodes-links
// bios.json
let filePath = './data/concepts-nodes-links.json'

if(window.location.search.substr(1)){
	let [key, val] = window.location.search.substr(1).split("=")
	if(key==='c'){
		switch(val){
			case 'bios': filePath = './data/bios.json' 
				break;
			case 'concepts': filePath = './data/concepts-nodes-links.json' 
				break;
			case 'math': filePath = './data/math-nodes-links.json'; break;
		}
	}
}

function fixNodesAttributeToAttribute(fGraph, attrA, attrB, defaultValue=null, offset=0){
  fGraph.graphData().nodes.forEach(node=>{
    if(node.hasOwnProperty(attrB)){
      node[attrA] = node[attrB] + offset
    } else {
      if(defaultValue){
        node[attrA] = defaultValue
      } else {
        console.log("skip",attrB,node.hasOwnProperty(attrB), node.time,node)
        // delete node[attrA]
      }
    }
  })
}

function reinitializeForceGraph(fGraph){
  fGraph.nodeVisibility((node)=>{return node.visible})
  fGraph.linkVisibility((link)=>{
    if(!link.source.visible || !link.target.visible){return false} else {return true}
  })
  // fGraph.linkVisibility(fGraph.linkVisibility())
  // fGraph.nodeVisibility(fGraph.nodeVisibility())
  // fGraph.d3Force("link").force(fGraph.d3Force("link"))
  setNodeObjectsToSpriteLabels( fGraph, 8, null )
  setEdgeLabelByAttribute(fGraph, "relation");

  let relationToColorMap = {
        Is: "cyan",
      IsA: "cyan",
      Synonym: "blue",
      Antonym: "red",
      Wrote: "yellow",
      Succeeds: "cyan",
      Inspire: "pink",
      Adjacent: "brown",
        About:"pink",
        Created:"yellow"
  };
  setEdgeVisualsByAttributeMap(fGraph, "relation", relationToColorMap);

  let valToStr = {
      IsA: 0.5,
      Synonym: 0.5,
      Antonym: 0.5,
    };
    // setLinkStrengthsFromAttribute( fGraph, "relation", valToStr)

    let valToDist = {
      IsA: 200.0,
      Synonym: 300.0,
      Antonym: 1300.0,
    };
    setLinkDistancesFromAttribute(fGraph, "relation", valToDist);
}

window.addEventListener("resize", () => {
    let width = window.innerWidth;
    let height = window.innerHeight;
    fGraph.camera().aspect = width / height;
    fGraph.camera().updateProjectionMatrix();
    fGraph.renderer().setSize(width, height);
    fGraph.renderer().setPixelRatio(Math.min(window.devicePixelRatio, 2));
  });

function swingCameraToNode(fGraph, node){
  const distance = 300;
    const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
  fGraph.cameraPosition(
            { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }, // new position
            node, // lookAt ({ x, y, z })
            1500  // ms transition duration
          );
}


fetch(filePath).then(res => res.json()).then(data => {
// fetch('./data/bios.json').then(res => res.json()).then(data => {
// fetch('./data/math-nodes-links.json').then(res => res.json()).then(data => {
  fGraph = ForceGraph3D({rendererConfig:{ antialias: true, alpha: true, clearColor: "black" } } )
  (document.getElementById('3d-graph'))
    .graphData(data)
    .nodeId('id')
    .nodeAutoColorBy('id')
    .onNodeClick((node, event) => {
      if(togglePinNode(node)) swingCameraToNode(fGraph,node)
      unpinAllNodes()
        togglePinNode(node)
	    
      fGraph.graphData().links.forEach(l=>{
          if(l.source.label === node.label || l.target.label === node.label){
            l.source.visible = true
            l.target.visible = true
          }
      })
      
      reinitializeForceGraph(fGraph )
    })
    .onNodeDragEnd((node,event)=>{
    	pinNode(node)
    })
    // .onNodeHover(node=>{})
    .nodeLabel(node=>{
        return node.label ? node.label : null
    })
    .linkWidth(0.0) // 0 gives a Line
    .linkOpacity(.5)
    .linkResolution(5)
    .d3AlphaDecay(0.0)
    .d3VelocityDecay(0.9)
    .cooldownTicks(Infinity)
    .cooldownTime(Infinity)
    .linkDirectionalParticles(2)
    .linkDirectionalParticleSpeed(0.025)
    .linkDirectionalParticleWidth(2)
    .linkDirectionalParticleColor("white")
    .linkDirectionalParticleResolution(2);

    fGraph.d3Force("center").strength(0.0)
    // fGraph.d3Force("charge").strength(-200)

    fGraph.renderer().autoClear = false;

    let address = window.location.search
    let parameterList = new URLSearchParams(address)

	fGraph.scene().background = "red"
  // fixNodesAttributeToAttribute(fGraph, 'fx', 'time', null, -1900)
  // setLinkGradient(fGraph)
  console.log(fGraph.scene(), fGraph.graphData())

  fGraph.graphData().nodes.forEach(node=>{
    node.visible = node.visible
  })
  reinitializeForceGraph(fGraph)

});
</script>
    
</body>
</html>