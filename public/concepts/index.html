<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="//unpkg.com/force-graph"></script>
    <script src="//unpkg.com/three"></script>
    <script src="//unpkg.com/d3-force-3d"></script>
    <script src="//unpkg.com/3d-force-graph"></script>
    <script src="//unpkg.com/three-spritetext"></script>
    <script src="//unpkg.com/dat.gui"></script>
        
    <title>fdg - concepts</title>
</head>
<style>
	*
{
    margin: 0;
    padding: 0;
}

html,
body
{
    height: 100vh;
    /* font-family: 'Poppins'; */
}

body {
    overflow-x: hidden;
}

/* canvas */
.webgl
{
    position: absolute;
    top: 0;
    left: 0;
    outline: none;
    mix-blend-mode: exclusion;
}

.container {
    height: 100vh;
    display: grid;
    place-items:  center;
}

h1 {
   font-size: 5rem;
   text-transform: uppercase;
   color:black; 
}

.scene-tooltip{
    overflow:hidden;
}

.scene-container{
    overflow:hidden;
}
</style>
<!-- 
Nodes all sharing a connection of the same relationship type to the same target node, effectively have an attribute.
Toggling a single type of relationship to strength 0 or distance infinity, and low/no visbility 
  is the visual equivalent of thinking of the relationship as an attribute 
  (but that's not restricted to target)
Turning a shared relation-type-plus-target into an attribute, does that give that target extra value or less?
  Wandering child nodes, (taking the relationshipo with them as an attirbute)
  vs
  sucking those child nodes up into the source (indicated vis somehow)
 -->
<body>
    
        <div>
            <div id="3d-graph"></div>    
        </div>

        <script type="glsl" id="vshader">
          attribute float vertPos; 
          varying float fragPos; 
          void main() { 
            gl_Position = projectionMatrix*modelViewMatrix*vec4(position, 1.0); 
            fragPos = vertPos; 
          }
        </script>

        <script type="glsl" id="fshader">
          uniform vec3 color; 
          varying float fragPos; 
          void main() { 
            gl_FragColor = vec4(color, 1.0); 
          }
        </script>

        <script type="module" >

let fGraph
const imagesFolder = 'images/'
const circleAlphaMap = new THREE.TextureLoader().load(imagesFolder + "orb.png");
const rectAlphaMap = new THREE.TextureLoader().load(imagesFolder + "cropped-rect-mask.jpg");

let gui
let params = {
  shuffleRelations: false,
  forceCenterStrength: 0.3,
  forceChargeStrength: -100,
  timeOnYAxis: false,
  timeFuncMultiplier: -20.0,
  timeFuncInnerMult: -1.0,
  timeFuncOffset: 2025, 
  showAll: true,
  timeAxes: false,
  valToDist : {
      IsA: 200.0,
      Synonym: 300.0,
      Antonym: 1300.0,
    }
}
let valToStr = {
      IsA: 0.5,
      Synonym: 0.5,
      Antonym: 0.5,
    };
let relationForces = {}
let relationVisibility = {}
function initDatGui(fGraph){
  gui = new dat.GUI({ name: "My GUI" })
  gui.width = 400
  // gui.close()

  let relations = [... new Set(fGraph.graphData().links.map(l=>l.relation) ) ]

  let forcesFolder = gui.addFolder("Forces")
  forcesFolder.open()
  forcesFolder.add(params, "forceCenterStrength", 0, 1, 0.01).name("Center Str").onChange((val)=>{ setForceStrength() })
  forcesFolder.add(params, "forceChargeStrength", -1000, 0, 0.01).name("Charge Str").onChange((val)=>{ setForceStrength() })

  let relationsFolder = forcesFolder.addFolder("Relations")
  relationsFolder.open()

  relations.forEach(relation=>{
    relationForces[ relation ] = { forceLinkStrength: 0.7, forceLinkDistance: 100 }
    relationVisibility[relation] = true
    let relationFolder = relationsFolder.addFolder( relation )

    relationFolder.add(relationForces[ relation ], "forceLinkStrength", 0, 1, 0.01).name("Link Str").onChange((val)=>{ 
      valToStr[relation] = relationForces[relation].forceLinkStrength
      setLinkStrengthsFromAttribute(fGraph, "relation", valToStr)
    })
    setLinkStrengthsFromAttribute(fGraph, "relation", valToStr)

    relationFolder.add(relationForces[ relation ], "forceLinkDistance", 0, 1000, 0.01).name("Link Dist").onChange((val)=>{ 
      params.valToDist[relation] = relationForces[relation].forceLinkDistance
      setLinkDistancesFromAttribute(fGraph, "relation", params.valToDist )
    })
    setLinkDistancesFromAttribute(fGraph, "relation", params.valToDist )

    relationFolder.add(relationVisibility, relation ).name("Hide").onChange(val=>{
      fGraph.graphData().links.forEach(l=>{
        if(l.relation === relation){
          l.hide = !l.hide
          
        }
      })
      reinitializeLinkVisibility(fGraph)
    })
    // relationFolder.open()
  })

  function toggleTimeHelpers(){
    timeHelpers.forEach(h=>{ h.visible = true })
  }

  function reinitTime(){
    if(params.timeOnYAxis){ 
      pinNodeAxisToProperty(fGraph, 'y', 'time', (val)=> { 
        return timeFunc(val)
      } ) 
      
    }
    else { 
      unpinAllNodes()
      timeHelpers.forEach(h=>{ h.visible = false })
      }
    resetTimeHelpers()
  }

  forcesFolder.add(params, "timeOnYAxis").onChange(val=>{ reinitTime() })
  forcesFolder.add(params, "timeFuncMultiplier", -1000.0, 1000.0, .1).onChange( val => reinitTime() )
  forcesFolder.add(params, "timeFuncInnerMult", -100, 100.0, .1).onChange( val => reinitTime() )
  forcesFolder.add(params, "timeFuncOffset", -5000.0, 5000.0, .1).onChange( val => reinitTime() )
  forcesFolder.add(params, "shuffleRelations")

  let displayFolder = gui.addFolder("Display")
  displayFolder.open()

  displayFolder.add(params, "showAll").name("Show All").onChange(val=>{
    if(val){ 
      fGraph.graphData().nodes.forEach(node=> node.visible= true )
      reinitializeLinkVisibility(fGraph)  
    }
    else { 
      fGraph.graphData().nodes.forEach(node=> node.visible= false )
      let i = Math.floor(Math.random()*fGraph.graphData().nodes.length)
      fGraph.graphData().nodes[i].visible = true
      reinitializeLinkVisibility(fGraph)  
    }
    fGraph.nodeVisibility(fGraph.nodeVisibility())
    reinitializeForceGraph(fGraph)
  })

  displayFolder.add(params, "timeAxes").name("Time Axes").onChange(val=>resetTimeHelpers())


}

function reinitializeLinkVisibility(fGraph){
  fGraph.linkVisibility((link)=>{
    if(!link.source.visible || !link.target.visible || link.hide){return false} else {return true}
  })
}

window.addEventListener("keyup", (e) => onKeyUp(e), false);


function pinNodeAxisToProperty(fGraph, axis, prop, nonlinearFunc){
  fGraph.graphData().nodes.forEach(node=> {
    if(node.hasOwnProperty(prop)){
      node[ 'f'+ axis ] = nonlinearFunc ? nonlinearFunc( node[prop] ) : node[prop]
    } else {
      delete node[ 'f' + axis ]
    }
  })
}

const toggleHidingYearLabels = () => {
  for (let i = 0; i < scene.children.length; i++){
    if ( scene.children[i].name === 'yearHelper' ) { scene.children[i].visible = !scene.children[i].visible }
  }
  for(let i = 0; i < yearLabels.length; i++){ yearLabels[i].toggleVisibility() }
}

async function onKeyUp(event) {
  switch (event.key) {
    case "f":
        console.log("fGraph graphData", fGraph.graphData())
        filterVisibleByAttr(fGraph, 'reviewed')
    break;
    case "u":
        unpinAllNodes()
    break;
  }
}

function filterVisibleByAttr(fGraph, attr){
  fGraph.graphData().nodes.forEach(node => {
    node.visible = node[attr] 
  } )
  reinitializeForceGraph(fGraph)
}

function setNodeObjectsToSpriteLabels(fGraph, textHeight, color) {
  if (!color) color = (n) => "white";
  fGraph
    .nodeThreeObject((node) => {
    	if (node.image) {
			const imgTexture = new THREE.TextureLoader().load( imagesFolder + node.image, (img)=>{
				} )
				const material = new THREE.SpriteMaterial({
				map: imgTexture,
				alphaMap: node.type === "person" ? circleAlphaMap : null,
			})
			const sprite = new THREE.Sprite(material);

			const width = 24
			const height = node.ratio ? node.ratio*width : width
			sprite.scale.set(width, height)
			// sprite.scale.set(imgTexture.source.data.width, imgTexture.source.data.height) // async issue, don't have imgTexture.source.data yet
			return sprite;
			
    	} else {
    		let label = node.label ? node.label : node.id;

	      const sprite = new SpriteText(label);
	      sprite.material.depthWrite = false; // make sprite background transparent
	      sprite.color = color(node);
	      sprite.textHeight = textHeight;
      	return sprite;	
		}
    })
}

function setEdgeLabelByAttribute(fGraph, attribute) {
  fGraph.linkHoverPrecision(3.0);
  fGraph.linkLabel((link) => {
    if (link[attribute]) {
      return link[attribute];
    } else return "(missing)";
  });
}

function setEdgeVisualsByAttributeMap(fGraph, attribute, valueMap) {
	let color = new THREE.Color()
	fGraph.linkColor((link) => {
		if ( link.hasOwnProperty(attribute) && valueMap.hasOwnProperty(link[attribute]) ) {
			color.set(valueMap[ link[attribute] ])
			return color.getStyle();
		}
	});
}

function setLinkStrengthsFromAttribute(fGraph, attribute, valueToStrengthMap) {
  fGraph.d3Force("link").strength((link) => {
    // if(link['serendipity']){ return 0.0 } 
    if(!link.source.visible || !link.target.visible || link.hide){return 0.0}
    if (link[attribute] && valueToStrengthMap.hasOwnProperty(link[attribute])) {
      return valueToStrengthMap[link[attribute]];
    } else return 1.0;
  });
}

function setLinkGradient(fGraph){
  fGraph.linkThreeObject(link=>{
    const colors = new Float32Array([1,0,0,0,0,1]
      //[].concat(
            // ...[link.source, link.target]
              // .map(nodeColorScale)
              // .map(d3.color)
              // .map(({ r, g, b }) => [r, g, b].map(v => v / 255)
              
      );

          const material = new THREE.LineBasicMaterial({ 
            vertexColors: THREE.VertexColors, transparent: true, opacity:.5
          });

          // const material = new THREE.ShaderMaterial({
          //     vertexShader: document.getElementById('vshader').textContent,
          //     fragmentShader: document.getElementById('fshader').textContent,
          //     // uniforms: {
          //     //   color: {
          //     //       type: 'v3',
          //     //       value: col
          //     //   }
          //     // },
          //     // vertexColors: THREE.VertexColors,
          //     depthWrite: false,
          //     depthTest: false,
          //     lineWidth: 1, //this always defaults to 1, unfortunately
          //     transparent: true
          // });

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(2 * 3), 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

          return new THREE.Line(geometry, material);
  })
}

function setLinkDistancesFromAttribute(fGraph, attribute, valueToDistanceMap) {
  fGraph.d3Force("link").distance((link) => {
    if (link[attribute] && valueToDistanceMap.hasOwnProperty(link[attribute])) {
      return valueToDistanceMap[link[attribute]];
    } else {
      return 50.0
    }
  });
}


function pinNode(node) {
  node.fx = node.x;
  node.fy = node.y;
  node.fz = node.z;
}

function unpinNode(node) {
  node.fx = null;
  node.fy = null;
  node.fz = null;
}

function togglePinNode(node) {
  if (node.fx || node.fy || node.fz ) {
    unpinNode(node)
    return true
  } else {
    pinNode(node)
    return false
  }
}

function unpinAllNodes() {
  fGraph.graphData().nodes.forEach(unpinNode);
}

// concepts-nodes-links
// bios.json
let filePath = './data/concepts-nodes-links.json'

if(window.location.search.substr(1)){
	let [key, val] = window.location.search.substr(1).split("=")
	if(key==='c'){
		switch(val){
			case 'bios': filePath = './data/bios.json' 
				break;
			case 'concepts': filePath = './data/concepts-nodes-links.json' 
				break;
			case 'math': filePath = './data/math-nodes-links.json'; break;
      case 'philos': filePath = './data/philosopher-inluences3.json'; break;
		}
	}
}

function fixNodesAttributeToAttribute(fGraph, attrA, attrB, defaultValue=null, offset=0){
  fGraph.graphData().nodes.forEach(node=>{
    if(node.hasOwnProperty(attrB)){
      node[attrA] = node[attrB] + offset
    } else {
      if(defaultValue){
        node[attrA] = defaultValue
      } else {
        // delete node[attrA]
      }
    }
  })
}

function reinitializeForceGraph(fGraph){
  fGraph.nodeVisibility((node)=>{return node.visible})
  fGraph.linkVisibility(fGraph.linkVisibility())
  fGraph.nodeVisibility(fGraph.nodeVisibility())
  // fGraph.d3Force("link").force(fGraph.d3Force("link"))
  setNodeObjectsToSpriteLabels( fGraph, 8, null )
  setEdgeLabelByAttribute(fGraph, "relation");

  let relationToColorMap = {
        Is: "cyan",
      IsA: "cyan",
      Synonym: "blue",
      Antonym: "red",
      Wrote: "yellow",
      Succeeds: "cyan",
      Invented: "beige",
      Inspire: "pink",
      Adjacent: "brown",
        About:"pink",
        Created:"yellow"
  };
  setEdgeVisualsByAttributeMap(fGraph, "relation", relationToColorMap);

  
  setLinkStrengthsFromAttribute( fGraph, "relation", valToStr)
  setLinkDistancesFromAttribute(fGraph, "relation", params.valToDist);
}

window.addEventListener("resize", () => {
    let width = window.innerWidth;
    let height = window.innerHeight;
    fGraph.camera().aspect = width / height;
    fGraph.camera().updateProjectionMatrix();
    fGraph.renderer().setSize(width, height);
    fGraph.renderer().setPixelRatio(Math.min(window.devicePixelRatio, 2));
  });

function swingCameraToNode(fGraph, node){
  const distance = 300;
    const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
  fGraph.cameraPosition(
            { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }, // new position
            node, // lookAt ({ x, y, z })
            1500  // ms transition duration
          );
}

function setForceStrength(){
  fGraph.d3Force("center").strength(params.forceCenterStrength)
  fGraph.d3Force("charge").strength(params.forceChargeStrength)
}
function timeFunc(t){
  return params.timeFuncMultiplier*Math.sqrt( Math.max(  params.timeFuncOffset + params.timeFuncInnerMult*t , .00001 ) ) 
}

let timeHelpers = []
function setupTimeHelpers(){
  let circleGeom = new THREE.CircleGeometry( 2000, 2 )
  // circleGeom.vertices.shift()
  circleGeom.rotateX(Math.PI/2.0)
  for (let i = 0; i < 10; i++){
    // var gridHelper = new THREE.PolarGridHelper( 100, 16, 2, 16 )
    let circleMat = new THREE.LineBasicMaterial({color: new THREE.Color().setHSL( i/10.0, 0.0, i/10.0 ) })
    let gridHelper = new THREE.LineLoop( circleGeom, circleMat )
    console.log("timeFunc", i*200, timeFunc( i*200 ))
    gridHelper.translateY( timeFunc( i*200 ) )
    gridHelper.name = 'yearHelper'
    gridHelper.visible = params.timeAxes;
    timeHelpers.push(gridHelper)
    fGraph.scene().add(gridHelper)
  }
}

function resetTimeHelpers(){
  timeHelpers.forEach( (helper, index)=>{
    helper.position.y = ( timeFunc( index*200 ) )
    helper.visible = params.timeAxes
  })
}

fetch(filePath).then(res => {
  let json = res.json()
  console.log('res', res, json)
  return json
}).then(data => {
  console.log("data", data)
  fGraph = ForceGraph3D({rendererConfig:{ antialias: true, alpha: true, clearColor: "black" } } )
  (document.getElementById('3d-graph'))
    .graphData(data)
    .nodeId('id')
    .nodeAutoColorBy('id')
    .onNodeClick((node, event) => {
      if(togglePinNode(node)) swingCameraToNode(fGraph,node)
      unpinAllNodes()
        togglePinNode(node)
	    
      fGraph.graphData().links.forEach(l=>{
        if(l.source.label === node.label || l.target.label === node.label){
          l.source.visible = true
          l.target.visible = true
        }
      })
      
      reinitializeForceGraph(fGraph )
    })
    .onNodeDragEnd((node,event)=>{
    	pinNode(node)
    })
    // .onNodeHover(node=>{})
    .nodeLabel(node=>{
        return node.time ? node.time : node.label
    })
    .linkWidth(0.0) // 0 gives a Line
    .linkOpacity(.5)
    .linkResolution(5)
    .d3AlphaDecay(0.0)
    .d3VelocityDecay(0.9)
    .cooldownTicks(Infinity)
    .cooldownTime(Infinity)
    .linkDirectionalParticles(2)
    .linkDirectionalParticleSpeed(0.0125)
    .linkDirectionalParticleWidth(1)
    .linkDirectionalParticleColor("white")
    .linkDirectionalParticleResolution(2)

    setForceStrength()

    fGraph.renderer().autoClear = false;

    let address = window.location.search
    let parameterList = new URLSearchParams(address)

	fGraph.scene().background = "red"
  // fixNodesAttributeToAttribute(fGraph, 'fx', 'time', null, -1900)
  // setLinkGradient(fGraph)

  fGraph.graphData().nodes.forEach(node=>{
    node.visible = true
  })
  reinitializeForceGraph(fGraph)
  reinitializeLinkVisibility(fGraph)
  initDatGui(fGraph)

  setupTimeHelpers()
  resetTimeHelpers()

});

function randomlyToggleLink(){
  const l = fGraph.graphData().links[ Math.floor(Math.random()*fGraph.graphData().links.length) ]
  l.hide = !l.hide
  // if(!l.hide){
    
  // } else {
    
  // }
  reinitializeLinkVisibility(fGraph) 
}

function shuffleRelations(){
  if(!params.shuffleRelations) return
  let relations = [...new Set(fGraph.graphData().links.map(l=>l.relation))]
  let threshold = 0.5*Math.sin(new Date()*.0002)+0.5

  let relation = relations[ Math.floor(Math.random()*relations.length) ]
  // relations.forEach(relation=>{
    const defaultStr = .4
    
    let visible = Math.random() > threshold
    if(!visible){
      relationForces[relation].forceLinkStrength = 0
      valToStr[relation] = relationForces[relation].forceLinkStrength
    } else {
      relationForces[relation].forceLinkStrength = defaultStr
      valToStr[relation] = relationForces[relation].forceLinkStrength
    }
    fGraph.graphData().links.forEach(l=>{
      if(l.relation === relation){
        l.hide = !visible  
      } 
    })
  // })

  setLinkStrengthsFromAttribute(fGraph, "relation", valToStr)
  reinitializeLinkVisibility(fGraph)
  
}
setInterval( shuffleRelations, 100 )
// setInterval( randomlyToggleLink, 800 )

</script>
    
</body>
</html>