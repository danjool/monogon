<!DOCTYPE html>
<html>
<head>
    <title>Bluesky MUD Prototype</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/3.4.4/luxon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/11.1.1/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.7/axios.min.js"></script>
    <style>
        body { max-width: 800px; margin: 2rem auto; font-family: system-ui; padding: 1rem; }
        #gameArea { display: none; }
        .room { border: 1px solid #ccc; padding: 1rem; margin: 1rem 0; }
        .exits { color: #666; }
        .messages { height: 200px; overflow-y: scroll; border: 1px solid #eee; padding: 1rem; margin: 1rem 0; }
        button { margin: 0.5rem; padding: 0.5rem 1rem; }
        input[type="text"] { width: 80%; padding: 0.5rem; }
        .warning { background: #fff3cd; padding: 1rem; border: 1px solid #ffeeba; margin: 1rem 0; }
        .inventory { background: #e9ecef; padding: 1rem; margin: 1rem 0; }
        .players { color: #28a745; margin-bottom: 0.5rem; }
        .items { color: #dc3545; margin-bottom: 0.5rem; }
        .chat { color: #0066cc; }
    </style>
</head>
<body>
    <div id="loginArea">
        <h2>Bluesky MUD Prototype</h2>
        
        <div class="warning">
            <h3>‚ö†Ô∏è Security Notice</h3>
            <p>This is an experimental MUD using Bluesky's AT Protocol. Please:</p>
            <ul>
                <li>Use an App Password from bsky.social (not your main password)</li>
                <li>Create an App Password at <a href="https://bsky.app/settings/app-passwords">https://bsky.app/settings/app-passwords</a></li>
                <li>Learn about App Passwords at <a href="https://blueskyfeeds.com/en/faq-app-password">bsky.social/docs/app-passwords</a></li>
                <li>Understand this stores game data in your Bluesky repo</li>
            </ul>
        </div>

        <input type="text" id="identifier" placeholder="handle.bsky.social">
        <input type="password" id="password" placeholder="App Password">
        <button onclick="login()">Login</button>
    </div>

    <div id="gameArea">
        <div class="room">
            <h3 id="roomTitle">Loading...</h3>
            <p id="roomDesc"></p>
            <p class="players" id="playersHere"></p>
            <p class="items" id="itemsHere"></p>
            <p class="exits" id="exits"></p>
        </div>
        
        <div class="inventory" id="inventory">
            <h4>Inventory</h4>
            <div id="inventoryItems"></div>
        </div>
        
        <div class="messages" id="messages"></div>
        
        <input type="text" id="command" placeholder="Type a command (look, go [exit], say [message], take/drop [item], edit)">
        <button onclick="sendCommand()">Send</button>
    </div>

    <script>
        let agent = null;
        let currentRoom = null;
        let playerDid = null;
        let playerInventory = [];
        let lastMessageTime = {};
        
        const BSKY_SERVICE = 'https://bsky.social';
        const MUD_RECORD_TYPE = 'app.mud.room';
        const MUD_INVENTORY_TYPE = 'app.mud.inventory';
        const MUD_CHAT_TYPE = 'app.mud.chat';

        // Poll for room and chat updates every 5 seconds
        setInterval(async () => {
            if (currentRoom && playerDid) {
                await Promise.all([
                    enterRoom(currentRoom.owner, false),
                    fetchNewMessages()
                ]);
            }
        }, 5000);

        let warningIndex = 0;
        setInterval(() => {
            const warning = document.querySelector('.warning');
            const emojis = ['‚ö†Ô∏è', 'üö®', '‚ö°Ô∏è', 'üîí', 'üõë '];
            const nextEmoji = emojis[warningIndex++ % emojis.length];
            warning.querySelector('h3').textContent = (nextEmoji + ' Security Notice' + nextEmoji);
        }, 500);

        async function login() {
            const identifier = document.getElementById('identifier').value;
            const password = document.getElementById('password').value;
            
            try {
                const response = await axios.post(`${BSKY_SERVICE}/xrpc/com.atproto.server.createSession`, {
                    identifier,
                    password
                });

                if (response.data.accessJwt) {
                    agent = {
                        jwt: response.data.accessJwt,
                        did: response.data.did
                    };
                    
                    playerDid = response.data.did;
                    document.getElementById('loginArea').style.display = 'none';
                    document.getElementById('gameArea').style.display = 'block';
                    
                    await initializePlayerData();
                    addMessage('System', 'Connected to Bluesky MUD prototype');
                }
            } catch (error) {
                alert('Login failed: ' + (error.response?.data?.message || error.message));
            }
        }

        async function initializePlayerData() {
            try {
                await initializePlayerRoom();
                
                try {
                    await axios.post(`${BSKY_SERVICE}/xrpc/com.atproto.repo.createRecord`, {
                        repo: playerDid,
                        collection: MUD_INVENTORY_TYPE,
                        rkey: 'inv1',
                        record: {
                            items: [],
                            $type: MUD_INVENTORY_TYPE
                        }
                    }, {
                        headers: { 'Authorization': `Bearer ${agent.jwt}` }
                    });
                } catch (error) {
                    if (error.response?.status !== 500) {
                        throw error;
                    }
                }
                
                await loadInventory();
            } catch (error) {
                addMessage('System', 'Error initializing player data: ' + error.message);
            }
        }

        async function initializePlayerRoom() {
            try {
                await axios.post(`${BSKY_SERVICE}/xrpc/com.atproto.repo.createRecord`, {
                    repo: playerDid,
                    collection: MUD_RECORD_TYPE,
                    rkey: 'room1',
                    record: {
                        title: "A New Room",
                        description: "An empty room waiting to be described.",
                        exits: [],
                        items: [],
                        players: [],
                        owner: playerDid,
                        $type: MUD_RECORD_TYPE
                    }
                }, {
                    headers: { 'Authorization': `Bearer ${agent.jwt}` }
                });

                await enterRoom(playerDid);
            } catch (error) {
                if (error.response?.status === 500) {
                    await enterRoom(playerDid);
                } else {
                    addMessage('System', 'Error initializing room: ' + error.message);
                }
            }
        }

        async function loadInventory() {
            try {
                const response = await axios.get(
                    `${BSKY_SERVICE}/xrpc/com.atproto.repo.listRecords?repo=${playerDid}&collection=${MUD_INVENTORY_TYPE}`,
                    {
                        headers: { 'Authorization': `Bearer ${agent.jwt}` }
                    }
                );

                if (response.data.records?.length > 0) {
                    playerInventory = response.data.records[0].value.items;
                    updateInventoryDisplay();
                }
            } catch (error) {
                addMessage('System', 'Error loading inventory: ' + error.message);
            }
        }

        async function updateInventory() {
            try {
                const records = await axios.get(
                    `${BSKY_SERVICE}/xrpc/com.atproto.repo.listRecords?repo=${playerDid}&collection=${MUD_INVENTORY_TYPE}`,
                    {
                        headers: { 'Authorization': `Bearer ${agent.jwt}` }
                    }
                );

                const rkey = records.data.records[0].rkey;
                
                await axios.post(`${BSKY_SERVICE}/xrpc/com.atproto.repo.putRecord`, {
                    repo: playerDid,
                    collection: MUD_INVENTORY_TYPE,
                    rkey: rkey,
                    record: {
                        items: playerInventory,
                        $type: MUD_INVENTORY_TYPE
                    }
                }, {
                    headers: { 'Authorization': `Bearer ${agent.jwt}` }
                });
                
                updateInventoryDisplay();
            } catch (error) {
                addMessage('System', 'Error updating inventory: ' + error.message);
            }
        }

        function updateInventoryDisplay() {
            const inv = document.getElementById('inventoryItems');
            inv.innerHTML = playerInventory.length ? playerInventory.join(', ') : 'Empty';
        }

        async function enterRoom(ownerDid, updatePlayers = true) {
            try {
                if (updatePlayers && currentRoom) {
                    await updateRoom(currentRoom.owner, room => {
                        room.players = room.players.filter(p => p !== playerDid);
                        return room;
                    });
                }

                const response = await axios.get(
                    `${BSKY_SERVICE}/xrpc/com.atproto.repo.listRecords?repo=${ownerDid}&collection=${MUD_RECORD_TYPE}`,
                    {
                        headers: { 'Authorization': `Bearer ${agent.jwt}` }
                    }
                );

                if (response.data.records?.length > 0) {
                    const roomRecord = response.data.records[0].value;
                    currentRoom = roomRecord;
                    
                    if (updatePlayers) {
                        await updateRoom(ownerDid, room => {
                            if (!room.players.includes(playerDid)) {
                                room.players.push(playerDid);
                            }
                            return room;
                        });
                    }

                    document.getElementById('roomTitle').textContent = roomRecord.title;
                    document.getElementById('roomDesc').textContent = roomRecord.description;
                    
                    const exitsList = roomRecord.exits?.map(exit => 
                        `${exit.name} (${exit.did})`
                    ).join(', ') || 'none';
                    document.getElementById('exits').textContent = `Exits: ${exitsList}`;
                    
                    document.getElementById('playersHere').textContent = 
                        `Players here: ${roomRecord.players.join(', ') || 'none'}`;
                    document.getElementById('itemsHere').textContent = 
                        `Items here: ${roomRecord.items?.join(', ') || 'none'}`;
                    
                    if (updatePlayers) {
                        addMessage('System', `You entered ${roomRecord.title}`);
                    }
                }
            } catch (error) {
                addMessage('System', 'Error fetching room: ' + error.message);
            }
        }

        async function updateRoom(ownerDid, updateFn) {
            try {
                const response = await axios.get(
                    `${BSKY_SERVICE}/xrpc/com.atproto.repo.listRecords?repo=${ownerDid}&collection=${MUD_RECORD_TYPE}`,
                    {
                        headers: { 'Authorization': `Bearer ${agent.jwt}` }
                    }
                );

                if (response.data.records?.length > 0) {
                    const record = response.data.records[0];
                    const updatedRoom = updateFn(record.value);

                    await axios.post(`${BSKY_SERVICE}/xrpc/com.atproto.repo.putRecord`, {
                        repo: ownerDid,
                        collection: MUD_RECORD_TYPE,
                        rkey: record.rkey || 'room1',
                        record: {
                            ...updatedRoom,
                            $type: MUD_RECORD_TYPE
                        }
                    }, {
                        headers: { 'Authorization': `Bearer ${agent.jwt}` }
                    });
                }
            } catch (error) {
                addMessage('System', 'Error updating room: ' + error.message);
            }
        }

        async function editRoom() {
            if (currentRoom.owner !== playerDid) {
                addMessage('System', "You can only edit your own room!");
                return;
            }

            const newTitle = prompt('Enter new room title:', currentRoom.title);
            if (!newTitle) return;
            
            const newDesc = prompt('Enter new room description:', currentRoom.description);
            if (!newDesc) return;

            const exits = [];
            for (let i = 0; i < 3; i++) {
                const exitName = prompt(`Enter name for exit ${i + 1} (or leave empty to skip):`);
                if (!exitName) continue;
                
                const exitDid = prompt(`Enter DID for exit "${exitName}":`);
                if (!exitDid) continue;
                
                exits.push({ name: exitName, did: exitDid });
            }

            const itemsStr = prompt('Enter items (comma-separated):', 
                (currentRoom.items || []).join(','));
            const items = itemsStr ? itemsStr.split(',').map(i => i.trim()) : [];

            await updateRoom(playerDid, room => ({
                ...room,
                title: newTitle,
                description: newDesc,
                exits,
                items
            }));

            await enterRoom(playerDid);
        }

        async function fetchNewMessages() {
            try {
                const response = await axios.get(
                    `${BSKY_SERVICE}/xrpc/com.atproto.repo.listRecords?repo=${currentRoom.owner}&collection=${MUD_CHAT_TYPE}&limit=50`,
                    {
                        headers: { 'Authorization': `Bearer ${agent.jwt}` }
                    }
                );

                if (response.data.records?.length > 0) {
                    response.data.records.forEach(record => {
                        const chat = record.value;
                        if (chat.timestamp > (lastMessageTime[chat.sender] || 0)) {
                            addMessage(chat.sender, chat.message, 'chat');
                            lastMessageTime[chat.sender] = chat.timestamp;
                        }
                    });
                }
            } catch (error) {
                console.error('Error fetching messages:', error);
            }
        }

        async function sendChatMessage(message) {
                    try {
                        const timestamp = Date.now();
                        await axios.post(`${BSKY_SERVICE}/xrpc/com.atproto.repo.createRecord`, {
                            repo: currentRoom.owner,
                            collection: MUD_CHAT_TYPE,
                            rkey: `chat-${timestamp}`,
                            record: {
                                sender: playerDid,
                                message: message,
                                timestamp: timestamp,
                                $type: MUD_CHAT_TYPE
                            }
                        }, {
                            headers: { 'Authorization': `Bearer ${agent.jwt}` }
                        });
                        
                        addMessage('You', message, 'chat');
                    } catch (error) {
                        addMessage('System', 'Error sending message: ' + error.message);
                    }
                }

                function addMessage(sender, text, className = '') {
                    const messages = document.getElementById('messages');
                    const time = luxon.DateTime.now().toLocaleString(luxon.DateTime.TIME_SIMPLE);
                    const classAttr = className ? ` class="${className}"` : '';
                    messages.innerHTML += `<p${classAttr}><strong>${time} - ${sender}:</strong> ${marked.parse(text)}</p>`;
                    messages.scrollTop = messages.scrollHeight;
                }

                async function sendCommand() {
                    const commandInput = document.getElementById('command');
                    const rawCommand = commandInput.value;
                    const lowerCommand = rawCommand.toLowerCase();
                    commandInput.value = '';

                    if (lowerCommand === 'look') {
                        addMessage('System', `You look around ${currentRoom.title}.\n${currentRoom.description}`);
                    }
                    else if (lowerCommand.startsWith('go ')) {
                        const exitName = lowerCommand.substring(3).trim();
                        const exit = currentRoom.exits.find(e => e.name.toLowerCase() === exitName);
                        if (exit) {
                            await enterRoom(exit.did);
                        } else {
                            addMessage('System', `There is no exit named '${exitName}'`);
                        }
                    }
                    else if (lowerCommand.startsWith('say ')) {
                        const message = rawCommand.substring(4);
                        if (message.trim()) {
                            await sendChatMessage(message);
                        }
                    }
                    else if (lowerCommand === 'edit') {
                        await editRoom();
                    }
                    else if (lowerCommand.startsWith('take ')) {
                        const item = rawCommand.substring(5);
                        if (currentRoom.items?.includes(item)) {
                            await updateRoom(currentRoom.owner, room => {
                                room.items = room.items.filter(i => i !== item);
                                return room;
                            });
                            playerInventory.push(item);
                            await updateInventory();
                            addMessage('System', `You took ${item}`);
                            await enterRoom(currentRoom.owner);
                        } else {
                            addMessage('System', `There is no '${item}' here`);
                            addMessage('System', `Available items: ${currentRoom.items?.join(', ') || 'none'}`);
                        }
                    }
                    else if (lowerCommand.startsWith('drop ')) {
                        const item = rawCommand.substring(5);
                        if (playerInventory.includes(item)) {
                            playerInventory = playerInventory.filter(i => i !== item);
                            await updateInventory();
                            await updateRoom(currentRoom.owner, room => {
                                if (!room.items) room.items = [];
                                room.items.push(item);
                                return room;
                            });
                            addMessage('System', `You dropped ${item}`);
                            await enterRoom(currentRoom.owner);
                        } else {
                            addMessage('System', `You don't have '${item}'`);
                            addMessage('System', `Your inventory: ${playerInventory.join(', ') || 'empty'}`);
                        }
                    }
                    else {
                        addMessage('System', 'Unknown command. Try: look, go [exit name], say [message], take [item], drop [item], edit');
                    }
                }

                document.getElementById('command').addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendCommand();
                    }
                });
    </script>
</body>
</html>