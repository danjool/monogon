<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Book Thumbnail Viewer - Static Spherical Layout</title>
    <style> 
        body { 
            margin: 0; 
            padding: 0;
            overflow: hidden;
            background-color: black;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
    </style>
<!-- Matomo, a fingerprintless, GDPR compliant, no-cookies analytics -->
<script>
  var _paq = window._paq = window._paq || [];
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//analytics.monogon.net/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
</head>

<body>
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'https://esm.sh/three';
        import { OrbitControls } from 'https://esm.sh/three/examples/jsm/controls/OrbitControls.js';
        import { EffectComposer } from 'https://esm.sh/three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://esm.sh/three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://esm.sh/three/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'https://esm.sh/three/examples/jsm/postprocessing/ShaderPass.js';

        const tagShellRadiusRendered = 600;

        let flowerMaterials = [];
        let hermiteFlowers = [];
        let authorTendrils = [];
        let tagHoverSpheres = [];
        let bookHoverSpheres = [];
        let scene, bloomOnlyScene, camera, renderer, controls;

        let bloomComposer, finalComposer;

        let autoCam = false;
        let t = 0;
        let atlasManager;

        const InstancedAtlasMaterial = class extends THREE.ShaderMaterial {
            constructor(atlasTexture) {
                super({
                    uniforms: {
                        atlasTexture: { value: atlasTexture },
                        time: { value: 0 }
                    },
                    vertexShader: `
                        attribute vec4 uvBounds;
                        varying vec2 vUv;
                        varying float depth;
                        
                        void main() {
                            vUv = vec2(
                                mix(uvBounds.x, uvBounds.z, uv.x),
                                mix(uvBounds.y, uvBounds.w, uv.y)
                            );
                            
                            vec3 instancePosition = vec3(instanceMatrix[3]);
                            vec3 instanceScale = vec3(
                                length(instanceMatrix[0].xyz),
                                length(instanceMatrix[1].xyz),
                                length(instanceMatrix[2].xyz)
                            );
                            
                            vec3 toCamera = normalize(cameraPosition - instancePosition);
                            vec3 up = vec3(0.0, 1.0, 0.0);
                            vec3 right = normalize(cross(up, toCamera));
                            up = cross(toCamera, right);
                            
                            mat4 billboardMatrix = mat4(
                                vec4(right * instanceScale.x, 0.0),
                                vec4(up * instanceScale.y, 0.0),
                                vec4(toCamera, 0.0),
                                vec4(instancePosition, 1.0)
                            );
                            
                            vec4 worldPosition = billboardMatrix * vec4(position, 1.0);
                            depth = 2000./distance(cameraPosition, instancePosition);
                            gl_Position = projectionMatrix * viewMatrix * worldPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D atlasTexture;
                        varying vec2 vUv;
                        varying float depth;
                        
                        void main() {
                            vec4 texColor = texture2D(atlasTexture, vUv);
                            if (texColor.a < 0.001) {
                                discard; // Completely discard pixels where no book
                            } else {
                                gl_FragColor = vec4(texColor.rgb, depth);
                            }
                        }
                    `,
                    transparent: false
                });
            }
        };

        class BookSpriteProxy extends THREE.Object3D {
            constructor(instancedMesh, instanceIndex, uvBounds, scale) {
                super();
                this.instancedMesh = instancedMesh;
                this.instanceIndex = instanceIndex;
                this.scale.set(scale.x, scale.y, 1);
                
                const uvBoundsAttr = instancedMesh.geometry.attributes.uvBounds;
                uvBoundsAttr.setXYZW(instanceIndex, uvBounds[0], uvBounds[1], uvBounds[2], uvBounds[3]);
                uvBoundsAttr.needsUpdate = true;
            }
            
            updateMatrixWorld(force) {
                super.updateMatrixWorld(force);
                this.instancedMesh.setMatrixAt(this.instanceIndex, this.matrixWorld);
            }
        }

        class BookAtlasManager {
            constructor(atlasTexture, uvMap, maxInstances) {
                this.geometry = new THREE.PlaneGeometry(1, 1);
                this.material = new InstancedAtlasMaterial(atlasTexture);
                this.instancedMesh = new THREE.InstancedMesh(this.geometry, this.material, maxInstances);
                
                const uvBoundsAttribute = new THREE.InstancedBufferAttribute(
                    new Float32Array(maxInstances * 4), 4
                );
                this.geometry.setAttribute('uvBounds', uvBoundsAttribute);
                
                this.uvMap = uvMap;
                this.instanceIndex = 0;
                this.proxies = [];
            }
            
            createBookSprite(thumbnailKey) {
                if (this.instanceIndex >= this.instancedMesh.count) {
                    console.warn('Exceeded maximum instances');
                    return new THREE.Object3D();
                }
                
                const uvCoords = this.uvMap[thumbnailKey];
                if (!uvCoords) {
                    console.warn(`No UV coords for ${thumbnailKey}`);
                    return new THREE.Object3D();
                }
                
                const [uMin, vMin, uMax, vMax] = uvCoords;
                const uWidth = uMax - uMin;
                const vHeight = vMax - vMin;
                const atlasPixelWidth = uWidth * 3072;
                const atlasPixelHeight = vHeight * 3072;
                
                const maxDimension = Math.max(atlasPixelWidth, atlasPixelHeight);
                const scaleFactor = 60 / maxDimension;
                const scale = {
                    x: atlasPixelWidth * scaleFactor,
                    y: atlasPixelHeight * scaleFactor
                };
                
                const proxy = new BookSpriteProxy(this.instancedMesh, this.instanceIndex, uvCoords, scale);
                this.proxies.push(proxy);
                this.instanceIndex++;

                return proxy;
            }
            
            getInstancedMesh() {
                return this.instancedMesh;
            }
            
            updateAllMatrices() {
                this.instancedMesh.instanceMatrix.needsUpdate = true;
            }
        }

        async function loadBakedBooks() {
            const response = await fetch('./baked-books.json');
            return await response.json();
        }


        async function loadBakedTags() {
            const response = await fetch('./baked-tags.json');
            return await response.json();
        }

        async function loadAtlasData() {
            try {
                const response = await fetch('./atlas-uv-map.json');
                const uvMap = await response.json();
                
                const atlasTexture = new THREE.TextureLoader().load('./atlas_optimized_4096.png');
                atlasTexture.generateMipmaps = true;
                atlasTexture.minFilter = THREE.LinearMipmapLinearFilter;
                atlasTexture.magFilter = THREE.LinearFilter;
                atlasTexture.wrapS = THREE.ClampToEdgeWrap;
                atlasTexture.wrapT = THREE.ClampToEdgeWrap;
                
                return { uvMap, atlasTexture };
            } catch (error) {
                console.error('Failed to load atlas data:', error);
                return null;
            }
        }

        async function thumbnailInAtlas(rowNumber, uvMap) {
            const filename = `${rowNumber}.jpg`;
            return filename in uvMap;
        }

        function generateAuthorSuccessionLinks(nodes) {
            const links = [];
            const authorBooks = new Map();
            
            nodes.forEach(node => {
                (node.authors || []).forEach(author => {
                    if (author !== 'NA' && !authorBooks.has(author)) {
                        authorBooks.set(author, []);
                    }
                    if (author !== 'NA') {
                        authorBooks.get(author).push(node);
                    }
                });
            });
            
            authorBooks.forEach((books, author) => {
                if (books.length > 1) {
                    books.sort((a, b) => {
                        const yearA = parseInt(a.first_publish_year) || 9999;
                        const yearB = parseInt(b.first_publish_year) || 9999;
                        return yearA - yearB;
                    });
                    
                    for (let i = 0; i < books.length - 1; i++) {
                        links.push({
                            source: books[i],
                            target: books[i + 1],
                            author: author,
                            type: 'author-succession'
                        });
                    }
                }
            });
            
            return links;
        }

        class TendrilPool {
            constructor(tagLinks, tagColors) {
                this.pools = [];
                this.distanceRanges = [];
                
                // Handle empty tag links
                if (!tagLinks || tagLinks.length === 0) {
                    console.log('No tag links provided to TendrilPool');
                    return;
                }
                
                // Pre-calculate all distances and assign to ranges
                const linkData = tagLinks.map(link => {
                    // Use rendered position for distance calculation
                    const tagSimulatedPos = new THREE.Vector3(link.target.x, link.target.y, link.target.z);
                    const tagPos = tagSimulatedPos.clone().normalize().multiplyScalar(tagShellRadiusRendered);
                    const bookPos = new THREE.Vector3(
                        link.source.x, 
                        link.source.y + (link.source.spriteProxy ? link.source.spriteProxy.scale.y / 2 : 0), 
                        link.source.z
                    );
                    return {
                        link,
                        distance: tagPos.distanceTo(bookPos)
                    };
                });
                
                const distances = linkData.map(d => d.distance);
                const sortedDistances = [...distances].sort((a, b) => a - b);
                const minDist = sortedDistances[0];
                const maxDist = sortedDistances[sortedDistances.length - 1];
                
                if (minDist === undefined || maxDist === undefined) {
                    console.log('No valid distances calculated for TendrilPool');
                    return;
                }
                
                console.log(`Distance range: ${minDist.toFixed(1)} to ${maxDist.toFixed(1)}`);
                
                // Create 8 distance-based ranges and count how many links fall into each
                const rangeCount = 8;
                const rangeCounts = new Array(rangeCount).fill(0);
                
                // Create ranges
                for (let i = 0; i < rangeCount; i++) {
                    const rangeStart = minDist + (i / rangeCount) * (maxDist - minDist);
                    const rangeEnd = minDist + ((i + 1) / rangeCount) * (maxDist - minDist);
                    const rangeMid = (rangeStart + rangeEnd) / 2;
                    
                    this.distanceRanges.push({
                        min: rangeStart,
                        max: rangeEnd,
                        unitDistance: rangeMid,
                        poolIndex: i,
                        linksInRange: []
                    });
                }
                
                // Assign each link to its range and count
                linkData.forEach(linkData => {
                    const distance = linkData.distance;
                    const rangeIndex = Math.min(
                        Math.floor((distance - minDist) / (maxDist - minDist) * rangeCount),
                        rangeCount - 1
                    );
                    this.distanceRanges[rangeIndex].linksInRange.push(linkData);
                    rangeCounts[rangeIndex]++;
                });
                
                // Create diverse tendril geometries for each distance range
                this.distanceRanges.forEach((range, rangeIndex) => {
                    if (range.linksInRange.length === 0) {
                        console.log(`  Skipping empty range ${rangeIndex}`);
                        return; // Skip empty ranges
                    }
                    
                    // Create multiple geometry variations per range based on actual usage
                    const linksInRange = range.linksInRange.length;
                    const variationsPerRange = Math.min(6, Math.max(1, Math.ceil(linksInRange / 50))); // 1-6 variations based on usage
                    const instancesPerPool = Math.ceil(linksInRange / variationsPerRange); // Exact fit
                    
                    console.log(`  Range ${rangeIndex}: ${linksInRange} links, ${variationsPerRange} variations, ${instancesPerPool} instances each`);
                    
                    for (let v = 0; v < variationsPerRange; v++) {
                        const dna = {
                            subdivisionLevels: 3 + Math.floor(Math.random() * 2),
                            organicVariation: 0.4 + Math.random() * 0.5,
                            startRadius: 2.2,
                            endRadius: 1.2,
                            tangentRandom: 0.8 + Math.random() * 1.0,
                            resolution: 6 + Math.floor(Math.random() * 4),
                            radialSegments: 4 + Math.floor(Math.random() * 3)
                        };
                        
                        // Generate tendril at realistic distance for this range
                        const unitStart = new THREE.Vector3(0, 0, 0);
                        const unitEnd = new THREE.Vector3(0, range.unitDistance, 0);
                        const pathPoints = genPathPointsRecursive(unitStart, unitEnd, dna);
                        const geometry = this.createTubeFromPoints(pathPoints, dna);
                    
                        const material = new THREE.ShaderMaterial({
                            vertexShader: `
                                attribute vec3 instanceColor;
                                varying vec2 vUv;
                                varying vec3 vInstanceColor;
                                uniform float time;
                                uniform float offset;
                                
                                void main() {
                                    vUv = uv;
                                    vInstanceColor = instanceColor;
                                    float d = length(position);
                                    float wave = sin(time*10. + offset*17.)*.5 + .5;
                                    vec3 pos = normalize(position)*max(d, 100.*wave);
                                    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
                                }
                            `,
                            fragmentShader: `
                                varying vec2 vUv;
                                varying vec3 vInstanceColor;
                                uniform float time;
                                uniform float offset;
                                
                                void main() {
                                    float wave = sin(-time*20. + (vUv.y) * 11.1 + offset*100. ) * 0.5 + 0.7; // + pow(sin(time*100. + (vUv.y) * 111.1 + offset*77. ), 2.) * 0.5;
                                    vec3 finalColor = vInstanceColor*wave;
                                    gl_FragColor = vec4(finalColor * 0.5, 1.0); 
                                }
                            `,
                            uniforms: {
                                time: { value: 0.0 },
                                offset: { value: (rangeIndex * variationsPerRange + v) / (rangeCount * variationsPerRange) }
                            },
                        });
                        
                        const instancedMesh = new THREE.InstancedMesh(geometry, material, instancesPerPool);
                        
                        // Add per-instance color attribute
                        const colors = new Float32Array(instancesPerPool * 3);
                        geometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(colors, 3));
                        
                        this.pools.push({
                            geometry,
                            material,
                            instancedMesh,
                            instanceCount: 0,
                            maxInstances: instancesPerPool,
                            dna,
                            distanceRange: range,
                            variationIndex: v
                        });
                        
                        flowerMaterials.push(material);
                    }
                });
            }
            
            createTubeFromPoints(points, dna) {
                const allPoints = [];
                
                for (let i = 0; i < points.length - 1; i++) {
                    const p0 = points[i];
                    const p1 = points[i + 1];
                    
                    let t0, t1;
                    if (i === 0) {
                        const originalDirection = p1.clone().sub(p0).normalize();
                        const radialBias = 1;
                        const radialComponent = p0.clone().normalize();
                        t0 = originalDirection.multiplyScalar(0.0).add(radialComponent.multiplyScalar(1.0)).normalize();
                    } else {
                        t0 = points[i + 1].clone().sub(points[i - 1]).normalize();
                    }
                    
                    if (i === points.length - 2) {
                        t1 = p1.clone().sub(p0).normalize();
                    } else {
                        t1 = points[i + 2].clone().sub(points[i]).normalize();
                    }
                    
                    t0 = this.addTangentRandomness(t0, dna.tangentRandom);
                    t1 = this.addTangentRandomness(t1, dna.tangentRandom);
                    
                    const segmentPoints = this.generateHermiteSegment(p0, p1, t0, t1, dna.resolution);
                    const pointsToAdd = i === 0 ? segmentPoints : segmentPoints.slice(1);
                    allPoints.push(...pointsToAdd);
                }
                
                const { radii, totalDistance } = this.calculateTaperedRadii(allPoints, dna.startRadius, dna.endRadius);
                return this.createCustomTubeGeometry(allPoints, radii, dna.radialSegments || 6, totalDistance);
            }
            
            addTangentRandomness(tangent, randomness) {
                return tangent.clone().add(new THREE.Vector3(
                    (Math.random() - 0.5) * randomness,
                    (Math.random() - 0.5) * randomness,
                    (Math.random() - 0.5) * randomness
                )).normalize();
            }
            
            generateHermiteSegment(p0, p1, t0, t1, resolution) {
                const points = [];
                const length0 = p1.distanceTo(p0) * 0.5;
                const length1 = p1.distanceTo(p0) * 0.5;
                
                for (let i = 0; i <= resolution; i++) {
                    const t = i / resolution;
                    const t2 = t * t;
                    const t3 = t2 * t;
                    
                    const h00 = 2 * t3 - 3 * t2 + 1;
                    const h10 = t3 - 2 * t2 + t;
                    const h01 = -2 * t3 + 3 * t2;
                    const h11 = t3 - t2;
                    
                    const point = p0.clone().multiplyScalar(h00)
                        .add(t0.clone().multiplyScalar(h10 * length0))
                        .add(p1.clone().multiplyScalar(h01))
                        .add(t1.clone().multiplyScalar(h11 * length1));
                    
                    points.push(point);
                }
                
                return points;
            }
            
            calculateTaperedRadii(points, startRadius, endRadius) {
                if (points.length === 0) return { radii: [], totalDistance: 0 };
                
                const distances = [0];
                let totalDistance = 0;
                for (let i = 1; i < points.length; i++) {
                    const distance = points[i].distanceTo(points[i - 1]);
                    totalDistance += distance;
                    distances.push(totalDistance);
                }
                
                const radii = [];
                for (let i = 0; i < points.length; i++) {
                    const t = totalDistance > 0 ? distances[i] / totalDistance : 0;
                    const radius = startRadius + (endRadius - startRadius) * t;
                    radii.push(radius);
                }
                
                return { radii, totalDistance };
            }
            
            createCustomTubeGeometry(points, radii, radialSegments, totalDistance) {
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const uvs = [];
                const indices = [];
                
                const frames = createParallelTransportFrames(points);
                
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const radius = radii[i];
                    const frame = frames[i];
                    
                    for (let j = 0; j <= radialSegments; j++) {
                        const angle = (j / radialSegments) * Math.PI * 2;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        const vertex = point.clone()
                            .add(frame.right.clone().multiplyScalar(x))
                            .add(frame.up.clone().multiplyScalar(y));
                        
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        
                        const u = j / radialSegments;
                        const v = i / (points.length - 1);
                        uvs.push(u, v);
                    }
                }
                
                for (let i = 0; i < points.length - 1; i++) {
                    for (let j = 0; j < radialSegments; j++) {
                        const a = i * (radialSegments + 1) + j;
                        const b = a + radialSegments + 1;
                        const c = a + 1;
                        const d = b + 1;
                        indices.push(a, b, c);
                        indices.push(b, d, c);
                    }
                }
                
                geometry.setIndex(indices);
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geometry.computeVertexNormals();
                
                return geometry;
            }
            
            assignLinks(tagLinks, tagColors) {
                const poolInstances = [];
                
                // Handle case where no pools were created (empty constructor)
                if (this.pools.length === 0) {
                    console.log('No tendril pools available for assignment');
                    return poolInstances;
                }
                
                // Process each distance range
                this.distanceRanges.forEach((range, rangeIndex) => {
                    if (range.linksInRange.length === 0) return;
                    
                    // Get pools for this range  
                    const rangePools = this.pools.filter(pool => pool.distanceRange === range);
                    
                    // Distribute links across pools in this range
                    range.linksInRange.forEach((linkData, linkIndex) => {
                        const poolIndex = linkIndex % rangePools.length;
                        const pool = rangePools[poolIndex];
                        const link = linkData.link;
                        
                        const tagNode = link.target;
                        const bookNode = link.source;
                        const tagPos = new THREE.Vector3(tagNode.x, tagNode.y, tagNode.z);
                        const start = tagPos.clone().normalize().multiplyScalar(tagShellRadiusRendered);
                        const end = new THREE.Vector3(
                            bookNode.x, 
                            bookNode.y + (bookNode.spriteProxy ? bookNode.spriteProxy.scale.y / 2 : 0), 
                            bookNode.z
                        );
                        
                        const direction = end.clone().sub(start);
                        const distance = linkData.distance;
                        
                        const matrix = new THREE.Matrix4();
                        
                        // Scale length to match actual distance vs unit distance  
                        const scale = distance / range.unitDistance;
                        matrix.makeScale(1, scale, 1);
                        
                        // Rotate to align with direction
                        const unitDirection = new THREE.Vector3(0, 1, 0);
                        const targetDirection = direction.normalize();
                        const quaternion = new THREE.Quaternion();
                        quaternion.setFromUnitVectors(unitDirection, targetDirection);
                        
                        const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
                        matrix.multiplyMatrices(rotationMatrix, matrix);
                        
                        //  Translate to start position
                        const translationMatrix = new THREE.Matrix4().makeTranslation(start.x, start.y, start.z);
                        matrix.multiplyMatrices(translationMatrix, matrix);
                        
                        pool.instancedMesh.setMatrixAt(pool.instanceCount, matrix);
                        
                        // Set color for this instance based on genre
                        const color = new THREE.Color(tagColors[link.tag] || '#ffffff');
                        const colorAttr = pool.geometry.attributes.instanceColor;
                        colorAttr.setXYZ(pool.instanceCount, color.r, color.g, color.b);
                        
                        pool.instanceCount++;
                    });
                });
                
                // Update all pools and collect used ones
                this.pools.forEach(pool => {
                    if (pool.instanceCount > 0) {
                        pool.instancedMesh.instanceMatrix.needsUpdate = true;
                        pool.geometry.attributes.instanceColor.needsUpdate = true;
                        pool.instancedMesh.count = pool.instanceCount;
                        poolInstances.push(pool.instancedMesh);
                    }
                });
                
                const totalRendered = this.pools.reduce((sum, pool) => sum + pool.instanceCount, 0);
                console.log(`Rendered all ${totalRendered} tendrils across ${poolInstances.length} pools - no skipping.`);
                
                return poolInstances;
            }
        }

        function generateHermiteFlowers(tagNodes, bookNodes, tagLinks, tagColors) {
            const tendrilPool = new TendrilPool(tagLinks, tagColors);
            return tendrilPool.assignLinks(tagLinks, tagColors);
        }
        
        function generateAuthorSuccessionTendrils(authorLinks) {
            if (authorLinks.length === 0) return [];
            
            // Create single InstancedMesh for all author links
            const geometry = new THREE.CylinderGeometry(1, 1, 1, 6);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 1.
            });
            
            const instancedMesh = new THREE.InstancedMesh(geometry, material, authorLinks.length);
            
            authorLinks.forEach((link, index) => {
                const sourceHeight = link.source.spriteProxy ? link.source.spriteProxy.scale.y : 0;
                const targetHeight = link.target.spriteProxy ? link.target.spriteProxy.scale.y : 0;
                
                // Get original positions
                const originalStart = new THREE.Vector3(
                    link.source.x, 
                    link.source.y,
                    link.source.z,
                );
                const originalEnd = new THREE.Vector3(
                    link.target.x, 
                    link.target.y,
                    link.target.z,
                );
                
                // Move positions inward toward origin by 20 units, looks better
                const start = originalStart.clone().normalize().multiplyScalar(originalStart.length() - 20);
                const end = originalEnd.clone().normalize().multiplyScalar(originalEnd.length() - 20);
                
                // Calculate transform matrix
                const direction = end.clone().sub(start);
                const distance = direction.length();
                const midpoint = start.clone().add(end).multiplyScalar(0.5);
                
                // Create matrix: scale by distance, rotate to align with direction, position at midpoint
                const matrix = new THREE.Matrix4();
                
                // Start with scaling (Y = length, X,Z = radius)
                matrix.makeScale(1, distance, 1);
                
                // Create rotation to align Y-axis with direction
                const up = new THREE.Vector3(0, 1, 0);
                const axis = direction.normalize();
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(up, axis);
                
                // Apply rotation, then  translation
                const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
                matrix.premultiply(rotationMatrix);
                const translationMatrix = new THREE.Matrix4().makeTranslation(midpoint.x, midpoint.y, midpoint.z);
                matrix.premultiply(translationMatrix);
                
                instancedMesh.setMatrixAt(index, matrix);
            });
            
            instancedMesh.instanceMatrix.needsUpdate = true;
            
            return [instancedMesh]; // an array of the instanced mesh, this used to be plain meshes
        }
        
        function genPathPointsRecursive(start, end, dna) {
            let points = [start.clone(), end.clone()];
            
            const subdivisionLevels = dna.subdivisionLevels || 4;
            const organicVariation = dna.organicVariation || .9;
            
            // Recursively subdivide and add organic variation
            for (let level = 0; level < subdivisionLevels; level++) {
                const newPoints = [];
                for (let i = 0; i < points.length - 1; i++) {
                    newPoints.push(points[i].clone());
                    
                    const midpoint = points[i].clone().lerp(points[i + 1], 0.5);
                    const distance = points[i].distanceTo(points[i + 1]);
                    const variation = distance * organicVariation / Math.pow(2, level);
                    
                    // Add perpendicular displacement
                    const direction = points[i + 1].clone().sub(points[i]).normalize();
                    let perp1 = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                    if (perp1.length() < 0.001) {
                        perp1 = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(1, 0, 0));
                    }
                    perp1.normalize();
                    const perp2 = new THREE.Vector3().crossVectors(direction, perp1).normalize();
                    
                    // Add radial bias for spherical context
                    const t = i / (points.length - 1);
                    
                    // Calculate radial bias based on book position relative to tag
                    const startRadial = start.clone().normalize();
                    const endRadial = end.clone().normalize();
                    const radialDot = startRadial.dot(endRadial);
                    
                    // If dot > 0, book is outward from tag; if dot < 0, book is inward
                    const radialBias = radialDot > 0 ? 1 : -1;
                    const radialInfluence = Math.exp(-t * 2) * variation * 0.5;
                    
                    // Create radial direction from origin to current point
                    const currentPoint = points[i].clone().lerp(points[i + 1], 0.5);
                    const radialDirection = currentPoint.clone().normalize();
                    
                    const displacement = perp1.clone().multiplyScalar((Math.random() - 0.5) * variation)
                        .add(perp2.clone().multiplyScalar((Math.random() - 0.5) * variation))
                        .add(radialDirection.clone().multiplyScalar(radialBias * radialInfluence));
                    
                    midpoint.add(displacement);
                    newPoints.push(midpoint);
                }
                newPoints.push(points[points.length - 1].clone());
                points = newPoints;
            }
            
            return points;
        }
        
        function createParallelTransportFrames(points) {
            if (points.length < 2) return [];
            
            const frames = [];
            const initialForward = points[1].clone().sub(points[0]).normalize();
            
            let initialUp = new THREE.Vector3(0, 1, 0);
            if (Math.abs(initialForward.dot(initialUp)) > 0.9) {
                initialUp = new THREE.Vector3(1, 0, 0);
            }
            
            const initialRight = new THREE.Vector3().crossVectors(initialForward, initialUp).normalize();
            initialUp = new THREE.Vector3().crossVectors(initialRight, initialForward).normalize();
            
            frames.push({
                forward: initialForward.clone(),
                right: initialRight.clone(),
                up: initialUp.clone()
            });
            
            for (let i = 1; i < points.length; i++) {
                const prevFrame = frames[i - 1];
                
                let newForward;
                if (i === points.length - 1) {
                    newForward = points[i].clone().sub(points[i - 1]).normalize();
                } else {
                    newForward = points[i + 1].clone().sub(points[i - 1]).normalize();
                }
                
                const rotationQuat = new THREE.Quaternion();
                rotationQuat.setFromUnitVectors(prevFrame.forward, newForward);
                
                const newRight = prevFrame.right.clone().applyQuaternion(rotationQuat);
                const newUp = prevFrame.up.clone().applyQuaternion(rotationQuat);
                
                frames.push({
                    forward: newForward.clone(),
                    right: newRight.clone(),
                    up: newUp.clone()
                });
            }
            
            return frames;
        }

        function generateDistinctPalette(count) {
            const colors = [];
            const hueStep = 360 / count;
            
            for (let i = 0; i < count; i++) {
                const hue = (i * hueStep) % 360;
                const color = hsvToHex(hue, 1., 1.0);
                colors.push(color);
            }
            
            return colors;
        }

        function hsvToHex(h, s, v) {
            const c = v * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = v - c;
            
            let r, g, b;
            if (h < 60) [r, g, b] = [c, x, 0];
            else if (h < 120) [r, g, b] = [x, c, 0];
            else if (h < 180) [r, g, b] = [0, c, x];
            else if (h < 240) [r, g, b] = [0, x, c];
            else if (h < 300) [r, g, b] = [x, 0, c];
            else [r, g, b] = [c, 0, x];
            
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);
            
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function setupBloomEffect() {
            const bloomScenePass = new RenderPass(bloomOnlyScene, camera);
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                .9,  // strength
                .4,  // radius  
                0.0  // threshold
            );
            
            bloomComposer = new EffectComposer(renderer);
            bloomComposer.renderToScreen = false;
            bloomComposer.addPass(bloomScenePass);
            bloomComposer.addPass(bloomPass);
            
            const mainScenePass = new RenderPass(scene, camera);
            const mixPass = new ShaderPass(
                new THREE.ShaderMaterial({
                    uniforms: {
                        baseTexture: { value: null },
                        bloomTexture: { value: bloomComposer.renderTarget2.texture }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }`,
                    fragmentShader: `
                        uniform sampler2D baseTexture;
                        uniform sampler2D bloomTexture;
                        varying vec2 vUv;
                        void main() {
                            vec4 baseColor = texture2D(baseTexture, vUv);
                            vec4 bloomColor = texture2D(bloomTexture, vUv);
                            
                            // baseColor.a has the depth of the baseColor (books)

                            vec3 mixed = bloomColor.xyz + (baseColor.xyz - bloomColor.xyz) * min(baseColor.a, 1.0);
                            gl_FragColor = vec4(mixed.xyz, 1.);

                        }`
                }), 'baseTexture'
            );
            mixPass.needsSwap = true;
            
            finalComposer = new EffectComposer(renderer);
            finalComposer.addPass(mainScenePass);
            finalComposer.addPass(mixPass);
        }


        async function initStaticApp() {
            const container = document.getElementById('container');
            
            scene = new THREE.Scene();
            bloomOnlyScene = new THREE.Scene(); // Create bloom scene early
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setClearColor(0x000000, 0.0); // Clear with transparent background, required for bloom mixing
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            camera.position.set(0, 0, 5000);
            controls.update();

            const [atlasData, bakedBooks, bakedTags] = await Promise.all([
                loadAtlasData(),
                loadBakedBooks(),
                loadBakedTags()
            ]);

            if (!atlasData) {
                console.error('Failed to load atlas data');
                return;
            }

            const { uvMap, atlasTexture } = atlasData;
            
            // Filter books that have thumbnails in atlas and baked positions
            const booksWithPositions = [];
            const allTags = new Set();

            for (const book of bakedBooks) {
                if (book.x !== undefined && book.y !== undefined && book.z !== undefined && 
                    await thumbnailInAtlas(book.rowNumber, uvMap)) {
                    const node = {
                        id: book.rowNumber,
                        title: book.title,
                        authors: book.authors || [],
                        first_publish_year: book.first_publish_year,
                        fiction: book.fiction || false,
                        tags: book.tags || [],
                        thumbnail: `${book.rowNumber}.jpg`,
                        type: 'book',
                        x: book.x,
                        y: book.y,
                        z: book.z
                    };
                    
                    (book.tags || []).forEach(tag => allTags.add(tag));
                    booksWithPositions.push(node);
                }
            }

            console.log('Books with positions:', booksWithPositions.length);

            // Generate color palette for tags
            const tagColors = {};
            const colors = generateDistinctPalette(allTags.size);
            Array.from(allTags).forEach((tag, index) => {
                tagColors[tag] = colors[index % colors.length];
            });

            atlasManager = new BookAtlasManager(atlasTexture, uvMap, booksWithPositions.length);

            booksWithPositions.forEach(book => {
                const spriteProxy = atlasManager.createBookSprite(book.thumbnail);
                book.spriteProxy = spriteProxy;
                
                spriteProxy.position.set(book.x, book.y, book.z);
                spriteProxy.updateMatrixWorld(true);
            });
            
            atlasManager.updateAllMatrices();

            scene.add(atlasManager.getInstancedMesh());
            console.log('Added InstancedMesh to scene with', atlasManager.instanceIndex, 'instances');

            const authorLinks = generateAuthorSuccessionLinks(booksWithPositions);
            
            const tagLinks = [];
            booksWithPositions.forEach(bookNode => {
                bookNode.tags.forEach(tag => {
                    const tagData = bakedTags.find(t => t.title === tag);
                    if (tagData) {
                        tagLinks.push({
                            source: bookNode,
                            target: tagData,
                            type: 'book-tag',
                            tag: tag
                        });
                    }
                });
            });

            console.log('Author succession links:', authorLinks.length);
            console.log('Genre to book links:', tagLinks.length);

            hermiteFlowers = generateHermiteFlowers(bakedTags, booksWithPositions, tagLinks, tagColors);
            hermiteFlowers.forEach(flower => {
                bloomOnlyScene.add(flower); // Add tendrils to bloom-only scene
            });

            authorTendrils = generateAuthorSuccessionTendrils(authorLinks);
            authorTendrils.forEach(tendril => {
                bloomOnlyScene.add(tendril); // Add tendrils to bloom-only scene
            });

            // Create hover detection spheres for books, this avoids us having to 
            booksWithPositions.forEach((book, index) => {
                const radius = Math.min(book.spriteProxy.scale.x, book.spriteProxy.scale.y) * 0.7;
                const sphereGeometry = new THREE.SphereGeometry(radius, 4, 3);
                const sphereMaterial = new THREE.MeshBasicMaterial({ visible: false });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(book.x, book.y, book.z);
                sphere.userData.bookData = book;
                sphere.userData.bookIndex = index;
                sphere.userData.isBookSphere = true;
                scene.add(sphere);
                bookHoverSpheres.push(sphere);
            });
            console.log(`Created ${bookHoverSpheres.length} book hover detection spheres`);

            // Create hover detection spheres for tags
            bakedTags.forEach(tagData => {
                const sphereGeometry = new THREE.SphereGeometry(70, 8, 6);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    visible: false
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(tagData.x, tagData.y, tagData.z);
                sphere.userData.tagData = tagData;
                sphere.userData.isTagSphere = true;
                scene.add(sphere);
                tagHoverSpheres.push(sphere);
            });

            setupBloomEffect();

            setupHoverDetection(booksWithPositions, atlasManager);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (event) => {
                if (event.key === 'c' || event.key === 'C') {
                    autoCam = !autoCam;
                    console.log('Auto camera:', autoCam);
                }
            });

            animate();
        }

        function setupHoverDetection(booksWithPositions, atlasManager) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let hoveredInstance = null;
            let hoverLabel = null;
            
            function createHoverLabel(text, x, y) {
                if (hoverLabel) {
                    document.body.removeChild(hoverLabel);
                }
                hoverLabel = document.createElement('div');
                hoverLabel.innerHTML = text;
                hoverLabel.style.position = 'absolute';
                hoverLabel.style.left = x + 'px';
                hoverLabel.style.top = y + 'px';
                hoverLabel.style.background = 'rgba(0,0,0,0.8)';
                hoverLabel.style.color = 'white';
                hoverLabel.style.padding = '5px';
                hoverLabel.style.borderRadius = '3px';
                hoverLabel.style.pointerEvents = 'none';
                hoverLabel.style.fontSize = '12px';
                hoverLabel.style.zIndex = '1000';
                document.body.appendChild(hoverLabel);
            }
            
            function removeHoverLabel() {
                if (hoverLabel) {
                    document.body.removeChild(hoverLabel);
                    hoverLabel = null;
                }
            }
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                const rect = event.target.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                // Check for tag sphere intersections first
                const tagSphereIntersects = raycaster.intersectObjects(tagHoverSpheres);
                if (tagSphereIntersects.length > 0) {
                    const tagSphere = tagSphereIntersects[0].object;
                    const tagData = tagSphere.userData.tagData;
                    
                    if (tagData && hoveredInstance !== `tag-${tagData.id}`) {
                        hoveredInstance = `tag-${tagData.id}`;
                        
                        // Count books with this tag
                        const bookCount = booksWithPositions.filter(book => 
                            book.tags.includes(tagData.title)
                        ).length;
                        
                        const labelText = `<strong>${tagData.title}</strong><br/>${bookCount} books`;
                        createHoverLabel(labelText, event.clientX + 10, event.clientY - 10);
                    }
                    return;
                }
                
                const bookSphereIntersects = raycaster.intersectObjects(bookHoverSpheres);
                if (bookSphereIntersects.length > 0) {
                    const bookSphere = bookSphereIntersects[0].object;
                    const bookData = bookSphere.userData.bookData;
                    const bookIndex = bookSphere.userData.bookIndex;
                    
                    if (bookData && hoveredInstance !== `book-${bookIndex}`) {
                        hoveredInstance = `book-${bookIndex}`;
                        
                        const labelText = `${bookData.title}<br/>${bookData.authors.join(', ')}<br/>${bookData.first_publish_year} (Row: ${bookData.id})<br/>${bookData.tags.join(', ')}`;
                        createHoverLabel(labelText, event.clientX + 10, event.clientY - 10);
                    }
                    return;
                }
                
                // No intersections found - clear hover state
                if (hoveredInstance !== null) {
                    hoveredInstance = null;
                    removeHoverLabel();
                }
            });
            
            renderer.domElement.addEventListener('mouseleave', () => {
                hoveredInstance = null;
                removeHoverLabel();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = performance.now() * 0.0001;
            flowerMaterials.forEach(material => {
                if (material.uniforms && material.uniforms.time) {
                    material.uniforms.time.value = elapsedTime;
                }
            });
                
                if (autoCam) {
                    const aheadAngle = 0.01;
                    const r2 = 3000 + Math.cos(elapsedTime);
                    const r1 = 4000 + 300 * (1 + Math.sin(elapsedTime*1.3));
                    
                    camera.position.set(
                        r1 * Math.sin(elapsedTime),
                        0,
                        r2 * Math.cos(elapsedTime),
                    );
                    
                    camera.lookAt(
                        0.3 * r1 * Math.sin(elapsedTime + Math.PI * aheadAngle),
                        0.5 * 3000 * Math.cos(elapsedTime + Math.PI * aheadAngle),
                        0,
                    );
                }
            controls.update();
            bloomComposer.render();
            finalComposer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            if (bloomComposer) {
                bloomComposer.setSize(window.innerWidth, window.innerHeight);
            }
            if (finalComposer) {
                finalComposer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        initStaticApp().catch(console.error);
    </script>
</body>
</html>