<!DOCTYPE html>
<html>
<head>
<style>
body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden }
#world { width: 100%; height: 100% }
</style>
<title>üêßPenguinsüêß</title> 
</head>
<body>
<div id="world"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const PENGUIN_COUNT = 12
const PLANE_SIZE = 100
let scene, camera, renderer, penguins = []

class Penguin {
    static bodyHeight = 1.2
    static bodyWidth = .9
    static bodyDepth = 0.8
    static bellyWidth = 0.8
    static bellyHeight = 1
    static bellyDepth = 0.7
    static bellyOffset = (Penguin.bodyDepth - Penguin.bellyDepth)*2.2
    static headOffset = Penguin.bodyHeight * 1.2

    constructor() {
        this.group = new THREE.Group()
        this.walkCycle = Math.random() * Math.PI * 2
        this.speed = 0.05 + Math.random() * 0.005
        this.heading = Math.random() * Math.PI * 2
        this.turnRate = (Math.random() - 0.5) * 0.02
        this.runningCycle = 0
        
        this.position = new THREE.Vector3(
            (Math.random() - 0.5) * PLANE_SIZE * 0.8,
            2,
            (Math.random() - 0.5) * PLANE_SIZE * 0.8
        )
        
        const body = new THREE.Mesh(
            new THREE.SphereGeometry(1, 12, 12),
            new THREE.MeshPhongMaterial({ color: 0x222222 })
        )
        body.scale.set(Penguin.bodyWidth, Penguin.bodyHeight, Penguin.bodyDepth)
        
        const belly = new THREE.Mesh(
            new THREE.SphereGeometry(0.9, 12, 12),
            new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
        )
        belly.scale.set(Penguin.bellyWidth, Penguin.bellyHeight, Penguin.bellyDepth)
        belly.position.z = Penguin.bellyOffset
        
        this.head = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 8, 8),
            new THREE.MeshPhongMaterial({ color: 0x222222 })
        )
        this.head.position.y = Penguin.headOffset
        
        const beak = new THREE.Mesh(
            new THREE.ConeGeometry(0.2, 0.5, 4),
            new THREE.MeshPhongMaterial({ color: 0xFFA500 })
        )
        beak.rotation.x = 2*Math.PI/3
        beak.position.set(0, 1.2, 0.6)

        // eyes
        const eye = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 8, 8),
            new THREE.MeshPhongMaterial({ color: 0xffffff })
        )
        eye.position.set(.3, .1, 0.45)
        this.head.add(eye.clone())
        eye.position.x = -.3
        this.head.add(eye.clone())

        
        this.leftFoot = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.1, 0.7),
            new THREE.MeshPhongMaterial({ color: 0xFFA500 })
        )
        this.leftFoot.position.set(0.4, -1.2, 0)
        
        this.rightFoot = this.leftFoot.clone()
        this.rightFoot.position.x = -0.4

        // hands (wings)
        this.handR = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.5, 0.5),
            new THREE.MeshPhongMaterial({ color: 0x222222 })
        )
        // this.handR.position.set(.8, .2, 0)
        // this.handR.rotation.x = -Math.PI/8
        // this.handR.rotation.z = -Math.PI/8
        // this.handL = this.handR.clone()
        // this.handL.position.x = -this.handR.position.x
        // this.handL.rotation.z = -this.handR.rotation.z

        this.group.add(
            body, belly, 
            this.head, beak, 
            this.leftFoot, this.rightFoot, 
            // this.handR, this.handL
        )
        this.group.traverse(obj => {
            if(obj.isMesh) {
                obj.castShadow = true
                obj.receiveShadow = true
            }
        })

        
        scene.add(this.group)
    }
    
    walk() {
        const t = this.walkCycle
        const amp = 0.5 // foot amplitude
        const PI = Math.PI

        this.walkCycle += this.speed
        this.runningCycle += this.speed

        if(Math.random() < 0.01) {
            this.turnRate = (Math.random() - 0.5) * 0.02
        }

        const distanceFromCenter = Math.sqrt(this.position.x ** 2 + this.position.z ** 2)
        const angleToCenter = Math.atan2(this.position.z, this.position.x)
        const angleDiff = angleToCenter - this.heading
        this.turnRate += angleDiff * 0.001 * (1 - Math.min(1, distanceFromCenter / (PLANE_SIZE * 0.8)))

        this.heading += Math.min(Math.max(this.turnRate, -0.03), 0.03)
        
        const movement = new THREE.Vector3(
            Math.sin(this.heading) * this.speed,
            0,
            Math.cos(this.heading) * this.speed
        )
        
        this.position.add(movement)
        
        if(this.position.x < -PLANE_SIZE * 0.5) this.position.x += PLANE_SIZE
        if(this.position.x > PLANE_SIZE * 0.5) this.position.x -= PLANE_SIZE
        if(this.position.z < -PLANE_SIZE * 0.5) this.position.z += PLANE_SIZE
        if(this.position.z > PLANE_SIZE * 0.5) this.position.z -= PLANE_SIZE

        this.group.position.copy(this.position)
        this.group.rotation.y = this.heading

        this.rightFoot.position.z = Math.cos(t) * amp
        this.leftFoot.position.z = Math.cos(t + PI) * amp
        this.leftFoot.position.y = -1.2 + Math.max(0, -Math.sin(t + PI) * amp)
        this.rightFoot.position.y = -1.2 + Math.max(0, -Math.sin(t) * amp)

        if( (t%(PI*2)) > PI) {
            this.rightFoot.rotation.x = Math.cos(-t * 2 + PI/2) * PI/8
            this.leftFoot.rotation.x = 0
        } else {
            this.rightFoot.rotation.x = 0
            this.leftFoot.rotation.x = Math.cos(-t * 2 + PI/2) * PI/8
        }

        this.group.position.y = Penguin.bodyHeight + Math.abs(Math.sin(this.walkCycle * 2)) * 0.1
        this.group.rotation.x = Math.cos(t) * 0.1
        this.group.rotation.z = Math.cos(t * 2) * 0.05

        // this.handR.position.z = -Math.cos( t + PI) * amp;
        // this.handL.position.z = -Math.cos( t ) * amp;
        // this.handR.rotation.z = -Math.cos( t + PI) * PI/8;
        // this.handL.rotation.z = -Math.cos( t ) * PI/8;
        this.head.rotation.z = Math.cos( t ) * amp * .02;
        this.head.rotation.y =  Math.cos( t ) * amp * .01;
    }
}

function init() {
    scene = new THREE.Scene()
    scene.background = new THREE.Color(0x87CEEB)
    
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000)
    camera.position.set(0, 50, 80)
    camera.lookAt(0, 0, 0)
    
    renderer = new THREE.WebGLRenderer({ antialias: true })
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.shadowMap.enabled = true
    document.getElementById('world').appendChild(renderer.domElement)
    
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE),
        new THREE.MeshPhongMaterial({ color: 0xEEEEEE, side: THREE.DoubleSide })
    )
    ground.rotation.x = -Math.PI/2
    ground.receiveShadow = true
    scene.add(ground)
    
    scene.add(new THREE.AmbientLight(0xFFFFFF, 0.4))
    
    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.8)
    directionalLight.position.set(50, 50, 50)
    directionalLight.castShadow = true
    directionalLight.shadow.camera.left = -50
    directionalLight.shadow.camera.right = 50
    directionalLight.shadow.camera.top = 50
    directionalLight.shadow.camera.bottom = -50
    scene.add(directionalLight)
    
    for(let i = 0; i < PENGUIN_COUNT; i++) {
        penguins.push(new Penguin())
    }

    function animate() {
        requestAnimationFrame(animate)
        penguins.forEach(penguin => penguin.walk())

        camera.position.lerp(penguins[0].position.clone().add(new THREE.Vector3(0, 0, 10)), 0.1)
        camera.lookAt(penguins[0].position.clone().add(new THREE.Vector3(0, -1, 0)))

        renderer.render(scene, camera)
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
    })
    
    animate()
}

init()
</script>
</body>
</html>